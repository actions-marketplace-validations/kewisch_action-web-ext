{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/errors.js","webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js","webpack:///./src/util/logger.js","webpack:///external \"path\"","webpack:///external \"mz\"","webpack:///external \"util\"","webpack:///./src/util/manifest.js","webpack:///external \"fs\"","webpack:///./src/util/stdin.js","webpack:///./src/firefox/remote.js","webpack:///external \"firefox-profile\"","webpack:///./src/util/file-filter.js","webpack:///external \"event-to-promise\"","webpack:///external \"bunyan\"","webpack:///./src/cmd/build.js","webpack:///./src/util/desktop-notifier.js","webpack:///external \"camelcase\"","webpack:///./src/extension-runners/index.js","webpack:///./src/firefox/index.js","webpack:///external \"os\"","webpack:///./src/cmd/index.js","webpack:///external \"parse-json\"","webpack:///external \"strip-json-comments\"","webpack:///./src/watcher.js","webpack:///./src/util/artifacts.js","webpack:///./src/firefox/preferences.js","webpack:///external \"readline\"","webpack:///./src/util/temp-dir.js","webpack:///./src/util/is-directory.js","webpack:///external \"tmp\"","webpack:///./src/config.js","webpack:///external \"git-rev-sync\"","webpack:///./src/program.js","webpack:///external \"yargs\"","webpack:///external \"watchpack\"","webpack:///external \"debounce\"","webpack:///./src/util/zip-dir.js","webpack:///external \"zip-dir\"","webpack:///external \"es6-error\"","webpack:///external \"mkdirp\"","webpack:///external \"multimatch\"","webpack:///external \"addons-linter\"","webpack:///external \"node-notifier\"","webpack:///external \"fx-runner\"","webpack:///external \"@cliqz-oss/node-firefox-connect\"","webpack:///external \"net\"","webpack:///./src/util/promisify.js","webpack:///./src/util/adb.js","webpack:///external \"adbkit\"","webpack:///external \"sign-addon\"","webpack:///external \"opn\"","webpack:///./src/util/updates.js","webpack:///external \"update-notifier\"","webpack:///external \"require-uncached\"","webpack:///external \"decamelize\"","webpack:///./src/util/file-exists.js","webpack:///./src/main.js","webpack:///./src/cmd/lint.js","webpack:///./src/cmd/run.js","webpack:///./src/extension-runners/firefox-desktop.js","webpack:///./src/extension-runners/firefox-android.js","webpack:///./src/cmd/sign.js","webpack:///./src/cmd/docs.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","WebExtError","UsageError","InvalidManifest","RemoteTempInstallNotSupported","MultiExtensionsReloadError","onlyErrorsWithCode","isErrorWithCode","es6_error__WEBPACK_IMPORTED_MODULE_0__","es6_error__WEBPACK_IMPORTED_MODULE_0___default","ExtendableError","constructor","message","super","errorsMap","errors","sourceDir","error","String","this","errorsBySourceDir","codeWanted","errorHandler","throwError","Array","isArray","indexOf","code","errno","obj","configurable","writable","ConsoleStream","verbose","_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default","isCapturing","capturedMessages","format","msg","level","nameFromLevel","makeVerbose","write","packet","localProcess","process","thisLevel","bunyan","TRACE","INFO","push","stdout","startCapturing","stopCapturing","flushCapturedLogs","consoleStream","createLogger","filename","createBunyanLog","defaultLogCreator","replace","streams","type","stream","require","__filename","getValidatedManifest","getManifestId","path__WEBPACK_IMPORTED_MODULE_0__","path__WEBPACK_IMPORTED_MODULE_0___default","mz__WEBPACK_IMPORTED_MODULE_1__","parse_json__WEBPACK_IMPORTED_MODULE_2__","parse_json__WEBPACK_IMPORTED_MODULE_2___default","strip_json_comments__WEBPACK_IMPORTED_MODULE_3__","strip_json_comments__WEBPACK_IMPORTED_MODULE_3___default","_errors__WEBPACK_IMPORTED_MODULE_4__","_logger__WEBPACK_IMPORTED_MODULE_5__","log","async","manifestFile","path","join","manifestContents","manifestData","debug","fs","readFile","encoding","parseJSON","stripJsonComments","version","applications","gecko","length","id","undefined","isTTY","setRawMode","rawMode","REMOTE_PORT","RemoteFirefox","client","checkedForAddonReloading","on","info","JSON","stringify","disconnect","addonRequest","addon","request","Promise","resolve","reject","makeRequest","to","actor","response","installTemporaryAddon","addonPath","tabsResponse","addonsActor","installResponse","getInstalledAddon","addonId","addons","then","map","a","[object Object]","requestTypes","supportedRequestTypes","checkForAddonReloading","Date","toTimeString","connect","port","connectToFirefox","defaultFirefoxConnector","connectWithMaxRetries","maxRetries","retryInterval","lastError","retries","stack","setTimeout","establishConnection","isSubPath","src","target","relate","relative","startsWith","sep","FileFilter","baseIgnoredPatterns","ignoreFiles","artifactsDir","filesToIgnore","addToIgnoreList","resolveWithSourceDir","file","resolvedPath","files","charAt","resolvedFile","substr","wantFile","filePath","multimatch","createFileFilter","params","safeFileName","getDefaultLocalizedName","defaultPackageCreator","build","fs__WEBPACK_IMPORTED_MODULE_1__","mz__WEBPACK_IMPORTED_MODULE_2__","parse_json__WEBPACK_IMPORTED_MODULE_3__","parse_json__WEBPACK_IMPORTED_MODULE_3___default","strip_json_comments__WEBPACK_IMPORTED_MODULE_4__","strip_json_comments__WEBPACK_IMPORTED_MODULE_4___default","event_to_promise__WEBPACK_IMPORTED_MODULE_5__","event_to_promise__WEBPACK_IMPORTED_MODULE_5___default","_watcher__WEBPACK_IMPORTED_MODULE_6__","_util_zip_dir__WEBPACK_IMPORTED_MODULE_7__","_util_manifest__WEBPACK_IMPORTED_MODULE_8__","_util_artifacts__WEBPACK_IMPORTED_MODULE_9__","_util_logger__WEBPACK_IMPORTED_MODULE_10__","_errors__WEBPACK_IMPORTED_MODULE_11__","_util_file_filter__WEBPACK_IMPORTED_MODULE_12__","toLowerCase","messageFile","messageData","messageContents","extensionName","match","messageName","fileFilter","overwriteDest","showReadyMessage","eventToPromise","defaultEventToPromise","buffer","zipDir","filter","args","default_locale","packageName","extensionPath","createWriteStream","flags","end","overwriteStream","asNeeded","defaultFileFilterCreator","onSourceChange","defaultSourceWatcher","packageCreator","rebuildAsNeeded","createPackage","prepareArtifactsDir","result","onChange","catch","shouldWatchFile","showDesktopNotification","node_notifier__WEBPACK_IMPORTED_MODULE_0__","node_notifier__WEBPACK_IMPORTED_MODULE_0___default","_logger__WEBPACK_IMPORTED_MODULE_1__","defaultLog","title","icon","notifier","defaultNotifier","notify","err","res","createExtensionRunner","config","FirefoxDesktopExtensionRunner","FirefoxAndroidExtensionRunner","MultiExtensionRunner","extensionRunners","runners","desktopNotifications","getName","promises","runner","run","all","reloadPromise","reloadAllExtensions","runnerName","reloadError","results","handleReloadResults","reloadExtensionBySourceDir","registerCleanup","cleanupCallback","exit","_ref","Error","defaultWatcherCreator","reloadExtension","defaultReloadStrategy","extensionRunner","noInput","createWatcher","stdin","kill","allowInput","watcher","watchedSourceDir","close","pause","readline","emitKeypressEvents","keypressUsageInfo","userExit","keyPressed","once","str","ctrl","pid","defaultAsyncFsStat","stat","defaultFirefoxEnv","XPCOM_DEBUG_BREAK","NS_TRACE_MALLOC_DISABLE_STACKS","defaultRemotePortFinder","portToTry","retriesLeft","profile","fxRunner","defaultFxRunner","findRemotePort","firefoxBinary","binaryArgs","remotePort","binary","binary-args","no-remote","listen","foreground","env","_objectSpread","firefox","stderr","data","toString","trim","debuggerPort","DEFAULT_PROFILES_NAMES","isDefaultProfile","profilePathOrName","ProfileFinder","FirefoxProfile","Finder","fsStat","includes","baseProfileDir","locateUserDirectory","profilesIniPath","finder","readProfiles","promisify","normalizedProfileDirPath","normalize","profiles","Name","Default","profileFullPath","IsRelative","Path","configureProfile","app","getPrefs","defaultPrefGetter","customPrefs","prefs","keys","forEach","pref","setPreference","customPrefsStr","custom","updatePreferences","defaultCreateProfileFinder","userDirectoryPath","FxProfile","getPath","profileDef","profileName","warn","useProfile","profilePath","configureThisProfile","isFirefoxDefaultProfile","createProfileFinder","destinationDirectory","getProfilePath","isDirectory","createProfile","copyProfile","profileDirectory","copyFromUserProfile","defaultUserProfileCopier","copy","copyByName","installExtension","asProxy","asyncFsStat","extensionsDir","mkdir","destPath","writeStream","nodeFs","readStream","createReadStream","pipe","options","default","runCommand","lint","sign","docs","watchpack__WEBPACK_IMPORTED_MODULE_0__","watchpack__WEBPACK_IMPORTED_MODULE_0___default","debounce__WEBPACK_IMPORTED_MODULE_1__","debounce__WEBPACK_IMPORTED_MODULE_1___default","_util_logger__WEBPACK_IMPORTED_MODULE_2__","Watchpack","debounce","proxyFileChanges","watch","now","util__WEBPACK_IMPORTED_MODULE_0__","mkdirp__WEBPACK_IMPORTED_MODULE_2__","mkdirp__WEBPACK_IMPORTED_MODULE_2___default","_errors__WEBPACK_IMPORTED_MODULE_3__","_logger__WEBPACK_IMPORTED_MODULE_4__","defaultAsyncMkdirp","mkdirp","defaultAsyncFsAccess","access","asyncMkdirp","asyncFsAccess","W_OK","accessErr","mkdirErr","nonOverridablePreferences","prefsCommon","browser.dom.window.dump.enabled","devtools.debugger.remote-enabled","devtools.debugger.prompt-connection","extensions.logging.enabled","extensions.checkCompatibility.nightly","extensions.update.enabled","extensions.update.notifyUser","extensions.enabledScopes","extensions.getAddons.cache.enabled","extensions.installDistroAddons","extensions.autoDisableScopes","app.update.enabled","xpinstall.signatures.required","common","fennec","browser.console.showInPanel","browser.firstrun.show.uidiscovery","browser.link.open_newwindow","devtools.remote.usb.enabled","browser.startup.homepage","startup.homepage_welcome_url","startup.homepage_welcome_url.additional","devtools.errorconsole.enabled","devtools.chrome.enabled","urlclassifier.updateinterval","browser.safebrowsing.provider.0.gethashURL","browser.safebrowsing.provider.0.keyURL","browser.safebrowsing.provider.0.updateURL","browser.selfsupport.url","browser.reader.detectedFirstArticle","datareporting.policy.firstRunURL","appPrefs","coerceCLICustomPreference","cliPrefs","prefsAry","split","slice","test","parseInt","tmp","dir","multiArgsPromisedFn","createTempDir","withTempDir","makePromise","tmpDir","TempDir","successHandler","_path","_removeTempDir","prefix","unsafeCleanup","tmpPath","removeTempDir","remove","promiseResult","mz__WEBPACK_IMPORTED_MODULE_0__","_errors__WEBPACK_IMPORTED_MODULE_1__","stats","applyConfigToArgv","argv","argvFromCLI","configObject","configFileName","newArgv","option","camelCase","decamelizedOptName","decamelize","expectedType","optionType","defaultValue","coerce","loadJSConfigFile","resolvedFilePath","requireUncached","endsWith","webExt","discoverConfigFiles","getHomeDir","os","homedir","possibleConfigs","cwd","configs","resolvedFileName","fileName","fileExists","existingConfigs","f","envPrefix","Program","absolutePackageDir","yargsInstance","yargs","verboseEnabled","shouldExitProgram","parserConfiguration","boolean-negation","strict","commands","command","description","executor","commandOptions","yargsForCmd","demandCommand","exitProcess","setGlobalOptions","global","demandOption","enableVerboseMode","logStream","checkForUpdates","defaultUpdateChecker","systemProcess","defaultLogStream","getVersion","defaultVersionGetter","defaultApplyConfigToArgv","defaultConfigDiscovery","defaultLoadJSConfigFile","globalEnv","WEBEXT_BUILD_ENV","cmd","_","adjustedArgv","configFiles","configDiscovery","noConfigDiscovery","discoveredConfigs","niceFileList","packageData","readFileSync","parse","git","branch","long","main","defaultCommands","runOptions","program","usage","help","alias","source-dir","describe","requiresArg","artifacts-dir","ignore-files","no-input","config-discovery","as-needed","overwrite-dest","api-key","api-secret","api-url-prefix","api-proxy","timeout","channel","choices","firefox-profile","keep-profile-changes","no-reload","pre-install","start-url","browser-console","adb-bin","adb-host","adb-port","adb-device","firefox-apk","output","metadata","warnings-as-errors","pretty","self-hosted","boring","execute","zip_dir__WEBPACK_IMPORTED_MODULE_1__","zip_dir__WEBPACK_IMPORTED_MODULE_1___default","zipDirModule","fn","callerArgs","rest","wrapADBCall","asyncFn","ADBUtils","adb","adbBin","adbHost","adbPort","defaultADB","adbClient","createClient","bin","host","artifactsDirMap","Map","userAbortDiscovery","runShellCommand","deviceId","shell","util","readAll","devices","listDevices","dev","firefoxApk","line","androidVersion","androidVersionNumber","isNaN","apk","permissions","permissionsMap","perm","pmDumpLogs","set","delete","localPath","devicePath","transfer","deviceProfileDir","startActivity","wait","action","component","extras","setUserAbortDiscovery","maxDiscoveryTime","rdpUnixSockets","discoveryStartedAt","pop","remote","local","forward","update_notifier__WEBPACK_IMPORTED_MODULE_0__","update_notifier__WEBPACK_IMPORTED_MODULE_0___default","updateNotifier","defaultUpdateNotifier","pkg","updateCheckInterval","fileIsReadable","constants","R_OK","isFile","_program__WEBPACK_IMPORTED_MODULE_0__","_cmd__WEBPACK_IMPORTED_MODULE_1__","logger","addons_linter__WEBPACK_IMPORTED_MODULE_0__","_util_logger__WEBPACK_IMPORTED_MODULE_1__","_util_file_filter__WEBPACK_IMPORTED_MODULE_2__","selfHosted","warningsAsErrors","createLinter","defaultLinterCreator","logLevel","Boolean","shouldScanFile","runAsBinary","browserConsole","firefoxProfile","keepProfileChanges","noReload","preInstall","startUrl","adbDevice","buildExtension","defaultBuildExtension","defaultDesktopNotifications","firefoxApp","defaultFirefoxApp","firefoxClient","defaultFirefoxClient","reloadStrategy","DefaultMultiExtensionRunner","defaultGetValidatedManifest","commonRunnerParams","extensions","firefoxDesktopRunnerParams","firefoxDesktopRunner","firefoxAndroidRunnerParams","buildSourceDir","extensionSourceDir","tmpArtifactsDir","firefoxAndroidRunner","reloadableExtensions","cleanupCallbacks","Set","setupProfileDir","startFirefoxInstance","reloadErrors","size","remoteFirefox","reloadAddon","add","runningInfo","extension","urls","url","cleanupCb","installResult","ignoredParams","getIgnoredParamsWarningsMessage","optionName","adbExtensionsPathBySourceDir","printIgnoredParamsWarnings","DefaultADBUtils","adbUtils","adbDevicesDiscoveryAndSelect","apkPackagesDiscoveryAndSelect","adbCheckRuntimePermissions","adbForceStopSelectedPackage","adbPrepareProfileDir","adbStartSelectedPackage","buildAndPushExtensions","adbDiscoveryAndForwardRDPUnixSocket","rdpInstallExtensions","buildAndPushExtension","selectedAdbDevice","selectedArtifactsDir","exiting","clearArtifactsDir","getDeviceProfileDir","ignoredParam","discoverDevices","devicesMsg","foundDevices","device","packages","discoverInstalledFirefoxAPKs","pkgsListMsg","pkgs","selectedFirefoxApk","filteredPackages","pkgsList","amForceStopAPK","getAndroidVersionNumber","Number","ensureRequiredAPKRuntimePermissions","getOrCreateArtifactsDir","pushFile","profileDir","startFirefoxAPK","extFileName","basename","adbExtensionPath","_ref2","firefoxAndroidTimeout","unixSocketDiscoveryRetryInterval","unixSocketDiscoveryMaxTime","handleCtrlC","selectedRDPSocketFile","discoverRDPUnixSocket","removeListener","tcpPort","chooseLocalTcpPort","forwardSocketSpec","setupForward","selectedTCPPort","srv","net","createServer","freeTcpPort","address","extensionIdFile","getIdFromSourceDir","saveIdToSourceDir","sign_addon__WEBPACK_IMPORTED_MODULE_2__","sign_addon__WEBPACK_IMPORTED_MODULE_2___default","_build__WEBPACK_IMPORTED_MODULE_3__","_util_manifest__WEBPACK_IMPORTED_MODULE_4__","_util_temp_dir__WEBPACK_IMPORTED_MODULE_5__","_errors__WEBPACK_IMPORTED_MODULE_6__","_util_artifacts__WEBPACK_IMPORTED_MODULE_7__","_util_logger__WEBPACK_IMPORTED_MODULE_8__","defaultAsyncFsReadFile","apiKey","apiProxy","apiSecret","apiUrlPrefix","defaultBuilder","preValidatedManifest","signAddon","defaultAddonSigner","buildResult","idFromSourceDir","manifestId","signingResult","xpiPath","downloadDir","success","asyncFsReadFile","content","lines","writeFile","opn__WEBPACK_IMPORTED_MODULE_0__","opn__WEBPACK_IMPORTED_MODULE_0___default","openUrl","opn"],"mappings":"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","file":"web-ext.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 56);\n","/* @flow */\nimport ExtendableError from 'es6-error';\n\n\n/*\n * Base error for all custom web-ext errors.\n */\nexport class WebExtError extends ExtendableError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n\n/*\n * The class for errors that can be fixed by the developer.\n */\nexport class UsageError extends WebExtError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n\n/*\n * The manifest for the extension is invalid (or missing).\n */\nexport class InvalidManifest extends UsageError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n\n/*\n * The remote Firefox does not support temporary add-on installation.\n */\nexport class RemoteTempInstallNotSupported extends WebExtError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n/*\n * The errors collected when reloading all extensions at once\n * (initialized from a map of errors by extensionSourceDir string).\n */\nexport class MultiExtensionsReloadError extends WebExtError {\n  constructor(errorsMap: Map<string, Error>) {\n    let errors = '';\n    for (const [sourceDir, error] of errorsMap) {\n      const msg = String(error);\n      errors += `\\nError on extension loaded from ${sourceDir}: ${msg}\\n`;\n    }\n    const message = `Reload errors: ${errors}`;\n\n    super(message);\n    this.errorsBySourceDir = errorsMap;\n  }\n}\n\n/*\n * Sugar-y way to catch only instances of a certain error.\n *\n * Usage:\n *\n *  Promise.reject(SyntaxError)\n *    .catch(onlyInstancesOf(SyntaxError, (error) => {\n *      // error is guaranteed to be an instance of SyntaxError\n *    }))\n *\n * All other errors will be re-thrown.\n *\n */\nexport function onlyInstancesOf(\n  predicate: Function, errorHandler: Function\n): Function {\n  return (error) => {\n    if (error instanceof predicate) {\n      return errorHandler(error);\n    } else {\n      throw error;\n    }\n  };\n}\n\n\n/*\n * Sugar-y way to catch only errors having certain code(s).\n *\n * Usage:\n *\n *  Promise.resolve()\n *    .catch(onlyErrorsWithCode('ENOENT', (error) => {\n *      // error.code is guaranteed to be ENOENT\n *    }))\n *\n *  or:\n *\n *  Promise.resolve()\n *    .catch(onlyErrorsWithCode(['ENOENT', 'ENOTDIR'], (error) => {\n *      // ...\n *    }))\n *\n * All other errors will be re-thrown.\n *\n */\nexport function onlyErrorsWithCode(\n  codeWanted: (string | number) | Array<string | number>,\n  errorHandler: Function\n): Function {\n  return (error) => {\n    let throwError = true;\n\n    if (Array.isArray(codeWanted)) {\n      if (codeWanted.indexOf(error.code) !== -1 ||\n          codeWanted.indexOf(error.errno) !== -1) {\n        throwError = false;\n      }\n    } else if (error.code === codeWanted || error.errno === codeWanted) {\n      throwError = false;\n    }\n\n    if (throwError) {\n      throw error;\n    }\n\n    return errorHandler(error);\n  };\n}\n\nexport function isErrorWithCode(\n  codeWanted: string | Array<string>,\n  error: Object,\n): boolean {\n  if (Array.isArray(codeWanted) && codeWanted.indexOf(error.code) !== -1) {\n    return true;\n  } else if (error.code === codeWanted) {\n    return true;\n  }\n\n  return false;\n}\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","/* @flow */\nimport bunyan, {nameFromLevel, createLogger as defaultLogCreator}\n  from 'bunyan';\n\n\n// Bunyan-related Flow types\n\nexport type TRACE = 10;\nexport type DEBUG = 20;\nexport type INFO = 30;\nexport type WARN = 40;\nexport type ERROR = 50;\nexport type FATAL = 60;\n\nexport type BunyanLogLevel =\n  TRACE | DEBUG | INFO | WARN | ERROR | FATAL;\n\nexport type BunyanLogEntry = {|\n  name: string,\n  msg: string,\n  level: BunyanLogLevel,\n|};\n\nexport type Logger = {\n  debug: (msg: string, ...args: any) => void,\n  error: (msg: string, ...args: any) => void,\n  info: (msg: string, ...args: any) => void,\n  warn: (msg: string, ...args: any) => void,\n};\n\n\n// ConsoleStream types and implementation.\n\nexport type ConsoleStreamParams = {|\n  verbose?: boolean,\n|};\n\nexport type ConsoleOptions = {|\n  localProcess?: typeof process,\n|};\n\nexport class ConsoleStream {\n  verbose: boolean;\n  isCapturing: boolean;\n  capturedMessages: Array<string>;\n\n  constructor({verbose = false}: ConsoleStreamParams = {}) {\n    this.verbose = verbose;\n    this.isCapturing = false;\n    this.capturedMessages = [];\n  }\n\n  format({name, msg, level}: BunyanLogEntry): string {\n    const prefix = this.verbose ? `[${name}][${nameFromLevel[level]}] ` : '';\n    return `${prefix}${msg}\\n`;\n  }\n\n  makeVerbose() {\n    this.verbose = true;\n  }\n\n  write(\n    packet: BunyanLogEntry,\n    {localProcess = process}: ConsoleOptions = {}\n  ): void {\n    const thisLevel: BunyanLogLevel = this.verbose ? bunyan.TRACE : bunyan.INFO;\n    if (packet.level >= thisLevel) {\n      const msg = this.format(packet);\n      if (this.isCapturing) {\n        this.capturedMessages.push(msg);\n      } else {\n        localProcess.stdout.write(msg);\n      }\n    }\n  }\n\n  startCapturing() {\n    this.isCapturing = true;\n  }\n\n  stopCapturing() {\n    this.isCapturing = false;\n    this.capturedMessages = [];\n  }\n\n  flushCapturedLogs({localProcess = process}: ConsoleOptions = {}) {\n    for (const msg of this.capturedMessages) {\n      localProcess.stdout.write(msg);\n    }\n    this.capturedMessages = [];\n  }\n}\n\nexport const consoleStream = new ConsoleStream();\n\n\n// createLogger types and implementation.\n\nexport type BunyanStreamConfig = {|\n  type: string,\n  stream: ConsoleStream,\n|};\n\nexport type CreateBunyanLogParams = {|\n  name: string,\n  level: BunyanLogLevel,\n  streams: Array<BunyanStreamConfig>,\n|};\n\nexport type CreateBunyanLogFn = (params: CreateBunyanLogParams) => Logger;\n\nexport type CreateLoggerOptions = {|\n  createBunyanLog: CreateBunyanLogFn,\n|};\n\nexport function createLogger(\n  filename: string,\n  {createBunyanLog = defaultLogCreator}: CreateLoggerOptions = {}\n): Logger {\n  return createBunyanLog({\n    // Strip the leading src/ from file names (which is in all file names) to\n    // make the name less redundant.\n    name: filename.replace(/^src\\//, ''),\n    // Capture all log levels and let the stream filter them.\n    level: bunyan.TRACE,\n    streams: [{\n      type: 'raw',\n      stream: consoleStream,\n    }],\n  });\n}\n","module.exports = require(\"path\");","module.exports = require(\"mz\");","module.exports = require(\"util\");","/* @flow */\nimport path from 'path';\n\nimport {fs} from 'mz';\nimport parseJSON from 'parse-json';\nimport stripJsonComments from 'strip-json-comments';\n\nimport {InvalidManifest} from '../errors';\nimport {createLogger} from './logger';\n\nconst log = createLogger(__filename);\n\n\n// getValidatedManifest helper types and implementation\n\nexport type ExtensionManifestApplications = {|\n  gecko: {|\n    id?: string,\n    strict_min_version?: string,\n    strict_max_version?: string,\n    update_url?: string,\n  |},\n|};\n\nexport type ExtensionManifest = {|\n  name: string,\n  version: string,\n  default_locale?: string,\n  applications?: ExtensionManifestApplications,\n|};\n\nexport default async function getValidatedManifest(\n  sourceDir: string\n): Promise<ExtensionManifest> {\n  const manifestFile = path.join(sourceDir, 'manifest.json');\n  log.debug(`Validating manifest at ${manifestFile}`);\n\n  let manifestContents;\n\n  try {\n    manifestContents = await fs.readFile(manifestFile, {encoding: 'utf-8'});\n  } catch (error) {\n    throw new InvalidManifest(\n      `Could not read manifest.json file at ${manifestFile}: ${error}`);\n  }\n\n  let manifestData;\n\n  try {\n    manifestData = parseJSON(stripJsonComments(manifestContents), manifestFile);\n  } catch (error) {\n    throw new InvalidManifest(\n      `Error parsing manifest.json at ${manifestFile}: ${error}`);\n  }\n\n  const errors = [];\n  // This is just some basic validation of what web-ext needs, not\n  // what Firefox will need to run the extension.\n  // TODO: integrate with the addons-linter for actual validation.\n  if (!manifestData.name) {\n    errors.push('missing \"name\" property');\n  }\n  if (!manifestData.version) {\n    errors.push('missing \"version\" property');\n  }\n\n  if (manifestData.applications && !manifestData.applications.gecko) {\n    // Since the applications property only applies to gecko, make\n    // sure 'gecko' exists when 'applications' is defined. This should\n    // make introspection of gecko properties easier.\n    errors.push('missing \"applications.gecko\" property');\n  }\n\n  if (errors.length) {\n    throw new InvalidManifest(\n      `Manifest at ${manifestFile} is invalid: ${errors.join('; ')}`);\n  }\n\n  return manifestData;\n}\n\n\nexport function getManifestId(manifestData: ExtensionManifest): string | void {\n  return manifestData.applications ?\n    manifestData.applications.gecko.id : undefined;\n}\n","module.exports = require(\"fs\");","/* @flow */\n\nimport type {Readable} from 'stream';\n\nexport function isTTY(stream: Readable): boolean {\n  // $FLOW_FIXME: flow complains that stream may not provide isTTY as a property.\n  return stream.isTTY;\n}\n\nexport function setRawMode(stream: Readable, rawMode: boolean) {\n  // $FLOW_FIXME: flow complains that stdin may not provide setRawMode.\n  stream.setRawMode(rawMode);\n}\n","/* @flow */\nimport defaultFirefoxConnector from '@cliqz-oss/node-firefox-connect';\n// RemoteFirefox types and implementation\nimport type FirefoxClient from '@cliqz-oss/firefox-client';\n\nimport {createLogger} from '../util/logger';\nimport {\n  isErrorWithCode,\n  RemoteTempInstallNotSupported,\n  UsageError,\n  WebExtError,\n} from '../errors';\n\nconst log = createLogger(__filename);\n\n// The default port that Firefox's remote debugger will listen on and the\n// client will connect to.\nexport const REMOTE_PORT = 6005;\n\nexport type FirefoxConnectorFn =\n  (port?: number) => Promise<FirefoxClient>;\n\nexport type FirefoxRDPAddonActor = {|\n  id: string,\n  actor: string,\n|};\n\nexport type FirefoxRDPResponseError = {|\n  error: {\n    message: string,\n  },\n|};\n\nexport type FirefoxRDPResponseAddon = {|\n  addon: FirefoxRDPAddonActor,\n|};\n\nexport type FirefoxRDPResponseRequestTypes = {|\n  requestTypes: Array<string>,\n|};\n\n// NOTE: this type aliases Object to catch any other possible response.\nexport type FirefoxRDPResponseAny = Object;\n\nexport type FirefoxRDPResponseMaybe =\n  FirefoxRDPResponseRequestTypes | FirefoxRDPResponseAny;\n\nexport class RemoteFirefox {\n  client: Object;\n  checkedForAddonReloading: boolean;\n\n  constructor(client: FirefoxClient) {\n    this.client = client;\n    this.checkedForAddonReloading = false;\n\n    client.client.on('disconnect', () => {\n      log.debug('Received \"disconnect\" from Firefox client');\n    });\n    client.client.on('end', () => {\n      log.debug('Received \"end\" from Firefox client');\n    });\n    client.client.on('message', (info) => {\n      // These are arbitrary messages that the client library ignores.\n      log.debug(`Received message from client: ${JSON.stringify(info)}`);\n    });\n  }\n\n  disconnect() {\n    this.client.disconnect();\n  }\n\n  addonRequest(\n    addon: FirefoxRDPAddonActor,\n    request: string\n  ): Promise<FirefoxRDPResponseMaybe> {\n    return new Promise((resolve, reject) => {\n      this.client.client.makeRequest(\n        {to: addon.actor, type: request}, (response) => {\n          if (response.error) {\n            const error = `${response.error}: ${response.message}`;\n            log.debug(\n              `Client responded to '${request}' request with error:`, error);\n            reject(new WebExtError(error));\n          } else {\n            resolve(response);\n          }\n        });\n    });\n  }\n\n  installTemporaryAddon(\n    addonPath: string\n  ): Promise<FirefoxRDPResponseAddon> {\n    return new Promise((resolve, reject) => {\n      this.client.request('listTabs', (error, tabsResponse) => {\n        if (error) {\n          return reject(new WebExtError(\n            `Remote Firefox: listTabs() error: ${error}`));\n        }\n        if (!tabsResponse.addonsActor) {\n          log.debug(\n            'listTabs returned a falsey addonsActor: ' +\n            `${tabsResponse.addonsActor}`);\n          return reject(new RemoteTempInstallNotSupported(\n            'This is an older version of Firefox that does not provide an ' +\n            'add-ons actor for remote installation. Try Firefox 49 or ' +\n            'higher.'));\n        }\n\n        this.client.client.makeRequest({\n          to: tabsResponse.addonsActor,\n          type: 'installTemporaryAddon',\n          addonPath,\n        }, (installResponse) => {\n          if (installResponse.error) {\n            return reject(new WebExtError(\n              'installTemporaryAddon: Error: ' +\n              `${installResponse.error}: ${installResponse.message}`));\n          }\n          log.debug(\n            `installTemporaryAddon: ${JSON.stringify(installResponse)}`);\n          log.info(`Installed ${addonPath} as a temporary add-on`);\n          resolve(installResponse);\n        });\n      });\n    });\n  }\n\n  getInstalledAddon(addonId: string): Promise<FirefoxRDPAddonActor> {\n    return new Promise(\n      (resolve, reject) => {\n        this.client.request('listAddons', (error, response) => {\n          if (error) {\n            reject(new WebExtError(\n              `Remote Firefox: listAddons() error: ${error}`));\n          } else {\n            resolve(response.addons);\n          }\n        });\n      })\n      .then((addons) => {\n        for (const addon of addons) {\n          if (addon.id === addonId) {\n            return addon;\n          }\n        }\n        log.debug(\n          `Remote Firefox has these addons: ${addons.map((a) => a.id)}`);\n        throw new WebExtError(\n          'The remote Firefox does not have your extension installed');\n      });\n  }\n\n  async checkForAddonReloading(\n    addon: FirefoxRDPAddonActor\n  ): Promise<FirefoxRDPAddonActor> {\n    if (this.checkedForAddonReloading) {\n      // We only need to check once if reload() is supported.\n      return addon;\n    } else {\n      const response = await this.addonRequest(addon, 'requestTypes');\n\n      if (response.requestTypes.indexOf('reload') === -1) {\n        const supportedRequestTypes = JSON.stringify(response.requestTypes);\n        log.debug(\n          `Remote Firefox only supports: ${supportedRequestTypes}`);\n        throw new UsageError(\n          'This Firefox version does not support add-on reloading. ' +\n          'Re-run with --no-reload');\n      } else {\n        this.checkedForAddonReloading = true;\n        return addon;\n      }\n    }\n  }\n\n  async reloadAddon(addonId: string): Promise<void> {\n    const addon = await this.getInstalledAddon(addonId);\n    await this.checkForAddonReloading(addon);\n    await this.addonRequest(addon, 'reload');\n    process.stdout.write(\n      `\\rLast extension reload: ${(new Date()).toTimeString()}`);\n    log.debug('\\n');\n  }\n}\n\n\n// Connect types and implementation\n\nexport type ConnectOptions = {|\n  connectToFirefox: FirefoxConnectorFn,\n|};\n\nexport async function connect(\n  port: number = REMOTE_PORT,\n  {connectToFirefox = defaultFirefoxConnector}: ConnectOptions = {}\n): Promise<RemoteFirefox> {\n  log.debug(`Connecting to Firefox on port ${port}`);\n  const client = await connectToFirefox(port);\n  log.debug(`Connected to the remote Firefox debugger on port ${port}`);\n  return new RemoteFirefox(client);\n}\n\n\n// ConnectWithMaxRetries types and implementation\n\nexport type ConnectWithMaxRetriesParams = {|\n  maxRetries?: number,\n  retryInterval?: number,\n  port: number,\n|};\n\nexport type ConnectWithMaxRetriesDeps = {|\n  connectToFirefox: typeof connect,\n|};\n\nexport async function connectWithMaxRetries(\n  // A max of 250 will try connecting for 30 seconds.\n  {maxRetries = 250, retryInterval = 120, port}: ConnectWithMaxRetriesParams,\n  {connectToFirefox = connect}: ConnectWithMaxRetriesDeps = {}\n): Promise<RemoteFirefox> {\n  async function establishConnection() {\n    var lastError;\n\n    for (let retries = 0; retries <= maxRetries; retries++) {\n      try {\n        return await connectToFirefox(port);\n      } catch (error) {\n        if (isErrorWithCode('ECONNREFUSED', error)) {\n          // Wait for `retryInterval` ms.\n          await new Promise((resolve) => {\n            setTimeout(resolve, retryInterval);\n          });\n\n          lastError = error;\n          log.debug(\n            `Retrying Firefox (${retries}); connection error: ${error}`);\n        } else {\n          log.error(error.stack);\n          throw error;\n        }\n      }\n    }\n\n    log.debug('Connect to Firefox debugger: too many retries');\n    throw lastError;\n  }\n\n  log.debug('Connecting to the remote Firefox debugger');\n  return establishConnection();\n}\n","module.exports = require(\"firefox-profile\");","/* @flow */\nimport path from 'path';\n\nimport multimatch from 'multimatch';\n\nimport {createLogger} from './logger';\n\nconst log = createLogger(__filename);\n\n// check if target is a sub directory of src\nexport const isSubPath = (src: string, target: string): boolean => {\n  const relate = path.relative(src, target);\n  // same dir\n  if (!relate) {\n    return false;\n  }\n  if (relate === '..') {\n    return false;\n  }\n  return !relate.startsWith(`..${path.sep}`);\n};\n\n// FileFilter types and implementation.\n\nexport type FileFilterOptions = {|\n  baseIgnoredPatterns?: Array<string>,\n  ignoreFiles?: Array<string>,\n  sourceDir: string,\n  artifactsDir?: string,\n|};\n\n/*\n * Allows or ignores files.\n */\nexport class FileFilter {\n  filesToIgnore: Array<string>;\n  sourceDir: string;\n\n  constructor({\n    baseIgnoredPatterns = [\n      '**/*.xpi',\n      '**/*.zip',\n      '**/.*', // any hidden file and folder\n      '**/.*/**/*', // and the content inside hidden folder\n      '**/node_modules',\n      '**/node_modules/**/*',\n    ],\n    ignoreFiles = [],\n    sourceDir,\n    artifactsDir,\n  }: FileFilterOptions = {}) {\n    sourceDir = path.resolve(sourceDir);\n\n    this.filesToIgnore = [];\n    this.sourceDir = sourceDir;\n\n    this.addToIgnoreList(baseIgnoredPatterns);\n    if (ignoreFiles) {\n      this.addToIgnoreList(ignoreFiles);\n    }\n    if (artifactsDir && isSubPath(sourceDir, artifactsDir)) {\n      artifactsDir = path.resolve(artifactsDir);\n      log.debug(\n        `Ignoring artifacts directory \"${artifactsDir}\" ` +\n        'and all its subdirectories'\n      );\n      this.addToIgnoreList([\n        artifactsDir,\n        path.join(artifactsDir, '**', '*'),\n      ]);\n    }\n  }\n\n  /**\n   *  Resolve relative path to absolute path with sourceDir.\n   */\n  resolveWithSourceDir(file: string): string {\n    const resolvedPath = path.resolve(this.sourceDir, file);\n    log.debug(\n      `Resolved path ${file} with sourceDir ${this.sourceDir} ` +\n      `to ${resolvedPath}`\n    );\n    return resolvedPath;\n  }\n\n  /**\n   *  Insert more files into filesToIgnore array.\n   */\n  addToIgnoreList(files: Array<string>) {\n    for (const file of files) {\n      if (file.charAt(0) === '!') {\n        const resolvedFile = this.resolveWithSourceDir(file.substr(1));\n        this.filesToIgnore.push(`!${resolvedFile}`);\n      } else {\n        this.filesToIgnore.push(this.resolveWithSourceDir(file));\n      }\n    }\n  }\n\n  /*\n   * Returns true if the file is wanted.\n   *\n   * If filePath does not start with a slash, it will be treated as a path\n   * relative to sourceDir when matching it against all configured\n   * ignore-patterns.\n   *\n   * Example: this is called by zipdir as wantFile(filePath) for each\n   * file in the folder that is being archived.\n   */\n  wantFile(filePath: string): boolean {\n    const resolvedPath = this.resolveWithSourceDir(filePath);\n    const matches = multimatch(resolvedPath, this.filesToIgnore);\n    if (matches.length > 0) {\n      log.debug(`FileFilter: ignoring file ${resolvedPath}`);\n      return false;\n    }\n    return true;\n  }\n}\n\n// a helper function to make mocking easier\n\nexport const createFileFilter = (\n  (params: FileFilterOptions): FileFilter => new FileFilter(params)\n);\n\nexport type FileFilterCreatorFn = typeof createFileFilter;\n","module.exports = require(\"event-to-promise\");","module.exports = require(\"bunyan\");","/* @flow */\nimport path from 'path';\nimport {createWriteStream} from 'fs';\n\nimport {fs} from 'mz';\nimport parseJSON from 'parse-json';\nimport stripJsonComments from 'strip-json-comments';\nimport defaultEventToPromise from 'event-to-promise';\n\nimport defaultSourceWatcher from '../watcher';\nimport {zipDir} from '../util/zip-dir';\nimport getValidatedManifest, {getManifestId} from '../util/manifest';\nimport {prepareArtifactsDir} from '../util/artifacts';\nimport {createLogger} from '../util/logger';\nimport {UsageError, isErrorWithCode} from '../errors';\nimport {\n  createFileFilter as defaultFileFilterCreator,\n  FileFilter,\n} from '../util/file-filter';\n// Import flow types.\nimport type {OnSourceChangeFn} from '../watcher';\nimport type {ExtensionManifest} from '../util/manifest';\nimport type {FileFilterCreatorFn} from '../util/file-filter';\n\nconst log = createLogger(__filename);\n\n\nexport function safeFileName(name: string): string {\n  return name.toLowerCase().replace(/[^a-z0-9.-]+/g, '_');\n}\n\n\n// defaultPackageCreator types and implementation.\n\nexport type ExtensionBuildResult = {|\n  extensionPath: string,\n|};\n\nexport type PackageCreatorParams = {|\n  manifestData?: ExtensionManifest,\n  sourceDir: string,\n  fileFilter: FileFilter,\n  artifactsDir: string,\n  overwriteDest: boolean,\n  showReadyMessage: boolean\n|};\n\nexport type LocalizedNameParams = {|\n  messageFile: string,\n  manifestData: ExtensionManifest,\n|}\n\nexport type PackageCreatorOptions = {|\n  eventToPromise: typeof defaultEventToPromise,\n|};\n\n// This defines the _locales/messages.json type. See:\n// https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Internationalization#Providing_localized_strings_in__locales\ntype LocalizedMessageData = {|\n  [messageName: string]: {|\n    description: string,\n    message: string,\n  |},\n|}\n\nexport async function getDefaultLocalizedName(\n  {messageFile, manifestData}: LocalizedNameParams\n): Promise<string> {\n\n  let messageData: LocalizedMessageData;\n  let messageContents: string | Buffer;\n  let extensionName: string = manifestData.name;\n\n  try {\n    messageContents = await fs.readFile(messageFile, {encoding: 'utf-8'});\n  } catch (error) {\n    throw new UsageError(\n      `Error reading messages.json file at ${messageFile}: ${error}`);\n  }\n\n  try {\n    messageData = parseJSON(stripJsonComments(messageContents), messageFile);\n  } catch (error) {\n    throw new UsageError(\n      `Error parsing messages.json ${error}`);\n  }\n\n  extensionName = manifestData.name.replace(\n    /__MSG_([A-Za-z0-9@_]+?)__/g,\n    (match, messageName) => {\n      if (!(messageData[messageName]\n            && messageData[messageName].message)) {\n        const error = new UsageError(\n          `The locale file ${messageFile} ` +\n            `is missing key: ${messageName}`);\n        throw error;\n      } else {\n        return messageData[messageName].message;\n      }\n    });\n  return Promise.resolve(extensionName);\n}\n\nexport type PackageCreatorFn =\n    (params: PackageCreatorParams) => Promise<ExtensionBuildResult>;\n\nexport async function defaultPackageCreator(\n  {\n    manifestData,\n    sourceDir,\n    fileFilter,\n    artifactsDir,\n    overwriteDest,\n    showReadyMessage,\n  }: PackageCreatorParams,\n  {\n    eventToPromise = defaultEventToPromise,\n  }: PackageCreatorOptions = {}\n): Promise<ExtensionBuildResult> {\n  let id;\n  if (manifestData) {\n    id = getManifestId(manifestData);\n    log.debug(`Using manifest id=${id || '[not specified]'}`);\n  } else {\n    manifestData = await getValidatedManifest(sourceDir);\n  }\n\n  const buffer = await zipDir(sourceDir, {\n    filter: (...args) => fileFilter.wantFile(...args),\n  });\n\n  let extensionName: string = manifestData.name;\n\n  let {default_locale} = manifestData;\n  if (default_locale) {\n    default_locale = default_locale.replace(/-/g, '_');\n    const messageFile = path.join(\n      sourceDir, '_locales',\n      default_locale, 'messages.json'\n    );\n    log.debug('Manifest declared default_locale, localizing extension name');\n    extensionName = await getDefaultLocalizedName({\n      messageFile, manifestData,\n    });\n  }\n  const packageName = safeFileName(\n    `${extensionName}-${manifestData.version}.zip`);\n  const extensionPath = path.join(artifactsDir, packageName);\n\n  // Added 'wx' flags to avoid overwriting of existing package.\n  const stream = createWriteStream(extensionPath, {flags: 'wx'});\n\n  stream.write(buffer, () => stream.end());\n\n  try {\n    await eventToPromise(stream, 'close');\n  } catch (error) {\n    if (!isErrorWithCode('EEXIST', error)) {\n      throw error;\n    }\n    if (!overwriteDest) {\n      throw new UsageError(\n        `Extension exists at the destination path: ${extensionPath}\\n` +\n        'Use --overwrite-dest to enable overwriting.');\n    }\n    log.info(`Destination exists, overwriting: ${extensionPath}`);\n    const overwriteStream = createWriteStream(extensionPath);\n    overwriteStream.write(buffer, () => overwriteStream.end());\n    await eventToPromise(overwriteStream, 'close');\n  }\n\n  if (showReadyMessage) {\n    log.info(`Your web extension is ready: ${extensionPath}`);\n  }\n  return {extensionPath};\n}\n\n\n// Build command types and implementation.\n\nexport type BuildCmdParams = {|\n  sourceDir: string,\n  artifactsDir: string,\n  asNeeded?: boolean,\n  overwriteDest?: boolean,\n  ignoreFiles?: Array<string>,\n|};\n\nexport type BuildCmdOptions = {|\n  manifestData?: ExtensionManifest,\n  fileFilter?: FileFilter,\n  onSourceChange?: OnSourceChangeFn,\n  packageCreator?: PackageCreatorFn,\n  showReadyMessage?: boolean,\n  createFileFilter?: FileFilterCreatorFn,\n  shouldExitProgram?: boolean,\n|};\n\nexport default async function build(\n  {\n    sourceDir,\n    artifactsDir,\n    asNeeded = false,\n    overwriteDest = false,\n    ignoreFiles = [],\n  }: BuildCmdParams,\n  {\n    manifestData,\n    createFileFilter = defaultFileFilterCreator,\n    fileFilter = createFileFilter({\n      sourceDir,\n      artifactsDir,\n      ignoreFiles,\n    }),\n    onSourceChange = defaultSourceWatcher,\n    packageCreator = defaultPackageCreator,\n    showReadyMessage = true,\n  }: BuildCmdOptions = {}\n): Promise<ExtensionBuildResult> {\n\n  const rebuildAsNeeded = asNeeded; // alias for `build --as-needed`\n  log.info(`Building web extension from ${sourceDir}`);\n\n  const createPackage = () => packageCreator({\n    manifestData,\n    sourceDir,\n    fileFilter,\n    artifactsDir,\n    overwriteDest,\n    showReadyMessage,\n  });\n\n  await prepareArtifactsDir(artifactsDir);\n  const result = await createPackage();\n\n  if (rebuildAsNeeded) {\n    log.info('Rebuilding when files change...');\n    onSourceChange({\n      sourceDir,\n      artifactsDir,\n      onChange: () => {\n        return createPackage().catch((error) => {\n          log.error(error.stack);\n          throw error;\n        });\n      },\n      shouldWatchFile: (...args) => fileFilter.wantFile(...args),\n    });\n  }\n\n  return result;\n}\n","/* @flow */\nimport defaultNotifier from 'node-notifier';\n\nimport {createLogger} from './logger';\nimport type {Logger} from './logger';\n\nconst defaultLog = createLogger(__filename);\n\nexport type DesktopNotificationsParams = {|\n  title: string,\n  message: string,\n  icon?: string,\n|};\n\nexport type DesktopNotificationsOptions = {|\n  notifier?: typeof defaultNotifier,\n  log?: Logger,\n|};\n\nexport function showDesktopNotification(\n  {\n    title, message, icon,\n  }: DesktopNotificationsParams,\n  {\n    notifier = defaultNotifier,\n    log = defaultLog,\n  }: DesktopNotificationsOptions = {}\n): Promise<void> {\n\n  return new Promise((resolve, reject) => {\n    notifier.notify({title, message, icon}, (err, res) => {\n      if (err) {\n        log.debug(`Desktop notifier error: ${err.message},` +\n                 ` response: ${res}`);\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n","module.exports = require(\"camelcase\");","/* @flow */\n\nimport readline from 'readline';\n\nimport type Watchpack from 'watchpack';\n\nimport type {\n  IExtensionRunner, // eslint-disable-line import/named\n  ExtensionRunnerReloadResult,\n} from './base';\nimport {WebExtError} from '../errors';\nimport {\n  showDesktopNotification as defaultDesktopNotifications,\n} from '../util/desktop-notifier';\nimport type {FirefoxAndroidExtensionRunnerParams} from './firefox-android';\nimport type {FirefoxDesktopExtensionRunnerParams} from './firefox-desktop';\nimport {createLogger} from '../util/logger';\nimport type {FileFilterCreatorFn} from '../util/file-filter';\nimport {\n  createFileFilter as defaultFileFilterCreator,\n} from '../util/file-filter';\nimport {\n  isTTY, setRawMode,\n} from '../util/stdin';\nimport defaultSourceWatcher from '../watcher';\nimport type {OnSourceChangeFn} from '../watcher';\n\n\nconst log = createLogger(__filename);\n\nexport type ExtensionRunnerConfig = {|\n  target: 'firefox-desktop',\n  params: FirefoxDesktopExtensionRunnerParams,\n|} | {|\n  target: 'firefox-android',\n  params: FirefoxAndroidExtensionRunnerParams,\n|};\n\nexport type MultiExtensionRunnerParams = {|\n  runners: Array<IExtensionRunner>,\n  desktopNotifications: typeof defaultDesktopNotifications,\n|};\n\nexport async function createExtensionRunner(config: ExtensionRunnerConfig) {\n  switch (config.target) {\n    case 'firefox-desktop': {\n      // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n      const {FirefoxDesktopExtensionRunner} = require('./firefox-desktop');\n      return new FirefoxDesktopExtensionRunner(config.params);\n    }\n    case 'firefox-android': {\n      // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n      const {FirefoxAndroidExtensionRunner} = require('./firefox-android');\n      return new FirefoxAndroidExtensionRunner(config.params);\n    }\n    default:\n      throw new WebExtError(`Unknown target: \"${config.target}\"`);\n  }\n}\n\n/**\n * Implements an IExtensionRunner which allow the caller to\n * manage multiple extension runners at the same time (e.g. by running\n * a Firefox Desktop instance alongside to a Firefox for Android instance).\n */\nexport class MultiExtensionRunner {\n  extensionRunners: Array<IExtensionRunner>;\n  desktopNotifications: typeof defaultDesktopNotifications;\n\n  constructor(params: MultiExtensionRunnerParams) {\n    this.extensionRunners = params.runners;\n    this.desktopNotifications = params.desktopNotifications;\n  }\n\n  // Method exported from the IExtensionRunner interface.\n\n  /**\n   * Returns the runner name.\n   */\n  getName() {\n    return 'Multi Extension Runner';\n  }\n\n  /**\n   * Call the `run` method on all the managed extension runners,\n   * and awaits that all the runners has been successfully started.\n   */\n  async run(): Promise<void> {\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      promises.push(runner.run());\n    }\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * Reloads all the extensions on all the managed extension runners,\n   * collect any reload error, and resolves to an array composed by\n   * a ExtensionRunnerReloadResult object per managed runner.\n   *\n   * Any detected reload error is also logged on the terminal and shows as a\n   * desktop notification.\n   */\n  async reloadAllExtensions(): Promise<Array<ExtensionRunnerReloadResult>> {\n    log.debug('Reloading all reloadable add-ons');\n\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      const reloadPromise = runner.reloadAllExtensions().then(\n        () => {\n          return {runnerName: runner.getName()};\n        },\n        (error) => {\n          return {\n            runnerName: runner.getName(),\n            reloadError: error,\n          };\n        }\n      );\n\n      promises.push(reloadPromise);\n    }\n\n    return await Promise.all(promises).then((results) => {\n      this.handleReloadResults(results);\n      return results;\n    });\n  }\n\n  /**\n   * Reloads a single extension on all the managed extension runners,\n   * collect any reload error and resolves to an array composed by\n   * a ExtensionRunnerReloadResult object per managed runner.\n   *\n   * Any detected reload error is also logged on the terminal and shows as a\n   * desktop notification.\n   */\n  async reloadExtensionBySourceDir(\n    sourceDir: string\n  ): Promise<Array<ExtensionRunnerReloadResult>> {\n    log.debug(`Reloading add-on at ${sourceDir}`);\n\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      const reloadPromise = runner.reloadExtensionBySourceDir(sourceDir).then(\n        () => {\n          return {runnerName: runner.getName(), sourceDir};\n        },\n        (error) => {\n          return {\n            runnerName: runner.getName(),\n            reloadError: error,\n            sourceDir,\n          };\n        }\n      );\n\n      promises.push(reloadPromise);\n    }\n\n    // $FLOW_FIXME: When upgrading to Flow 0.61.0, it could not follow the type of sourceDir in the array of promises.\n    return await Promise.all(promises).then((results) => {\n      this.handleReloadResults(results);\n      return results;\n    });\n  }\n\n  /**\n   * Register a callback to be called when all the managed runners has been exited.\n   */\n  registerCleanup(cleanupCallback: Function): void {\n    const promises = [];\n\n    // Create a promise for every extension runner managed by this instance,\n    // the promise will be resolved when the particular runner calls its\n    // registered cleanup callbacks.\n    for (const runner of this.extensionRunners) {\n      promises.push(new Promise((resolve) => {\n        runner.registerCleanup(resolve);\n      }));\n    }\n\n    // Wait for all the created promises to be resolved or rejected\n    // (once each one of the runners has cleaned up) and then call\n    // the cleanup callback registered to this runner.\n    Promise.all(promises).then(cleanupCallback, cleanupCallback);\n  }\n\n  /**\n   * Exits all the managed runner has been exited.\n   */\n  async exit(): Promise<void> {\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      promises.push(runner.exit());\n    }\n\n    await Promise.all(promises);\n  }\n\n  // Private helper methods.\n\n  handleReloadResults(results: Array<ExtensionRunnerReloadResult>): void {\n    for (const {runnerName, reloadError, sourceDir} of results) {\n      if (reloadError instanceof Error) {\n        let message = 'Error occurred while reloading';\n        if (sourceDir) {\n          message += ` \"${sourceDir}\" `;\n        }\n\n        message += `on \"${runnerName}\" - ${reloadError.message}`;\n\n        log.error(`\\n${message}`);\n        log.debug(reloadError.stack);\n\n        this.desktopNotifications({\n          title: 'web-ext run: extension reload error',\n          message,\n        });\n      }\n    }\n  }\n}\n\n// defaultWatcherCreator types and implementation.\n\nexport type WatcherCreatorParams = {|\n  reloadExtension: (string) => void,\n  sourceDir: string,\n  artifactsDir: string,\n  onSourceChange?: OnSourceChangeFn,\n  ignoreFiles?: Array<string>,\n  createFileFilter?: FileFilterCreatorFn,\n|};\n\nexport type WatcherCreatorFn = (params: WatcherCreatorParams) => Watchpack;\n\nexport function defaultWatcherCreator(\n  {\n    reloadExtension, sourceDir, artifactsDir, ignoreFiles,\n    onSourceChange = defaultSourceWatcher,\n    createFileFilter = defaultFileFilterCreator,\n  }: WatcherCreatorParams\n): Watchpack {\n  const fileFilter = createFileFilter(\n    {sourceDir, artifactsDir, ignoreFiles}\n  );\n  return onSourceChange({\n    sourceDir,\n    artifactsDir,\n    onChange: () => reloadExtension(sourceDir),\n    shouldWatchFile: (file) => fileFilter.wantFile(file),\n  });\n}\n\n\n// defaultReloadStrategy types and implementation.\n\nexport type ReloadStrategyParams = {|\n  extensionRunner: IExtensionRunner,\n  sourceDir: string,\n  artifactsDir: string,\n  ignoreFiles?: Array<string>,\n  noInput?: boolean,\n|};\n\nexport type ReloadStrategyOptions = {|\n  createWatcher?: WatcherCreatorFn,\n  stdin?: stream$Readable,\n  kill?: typeof process.kill,\n|};\n\nexport function defaultReloadStrategy(\n  {\n    artifactsDir,\n    extensionRunner,\n    ignoreFiles,\n    noInput = false,\n    sourceDir,\n  }: ReloadStrategyParams,\n  {\n    createWatcher = defaultWatcherCreator,\n    stdin = process.stdin,\n    kill = process.kill,\n  }: ReloadStrategyOptions = {}\n): void {\n  const allowInput = !noInput;\n  if (!allowInput) {\n    log.debug('Input has been disabled because of noInput==true');\n  }\n\n  const watcher: Watchpack = createWatcher({\n    reloadExtension: (watchedSourceDir) => {\n      extensionRunner.reloadExtensionBySourceDir(watchedSourceDir);\n    },\n    sourceDir,\n    artifactsDir,\n    ignoreFiles,\n  });\n\n  extensionRunner.registerCleanup(() => {\n    watcher.close();\n    if (allowInput) {\n      stdin.pause();\n    }\n  });\n\n  if (allowInput && isTTY(stdin)) {\n    readline.emitKeypressEvents(stdin);\n    setRawMode(stdin, true);\n\n    const keypressUsageInfo = 'Press R to reload (and Ctrl-C to quit)';\n\n    // NOTE: this `Promise.resolve().then(...)` is basically used to spawn a \"co-routine\"\n    // that is executed before the callback attached to the Promise returned by this function\n    // (and it allows the `run` function to not be stuck in the while loop).\n    Promise.resolve().then(async function() {\n      log.info(keypressUsageInfo);\n\n      let userExit = false;\n\n      while (!userExit) {\n        const keyPressed = await new Promise((resolve) => {\n          stdin.once('keypress', (str, key) => resolve(key));\n        });\n\n        if (keyPressed.ctrl && keyPressed.name === 'c') {\n          userExit = true;\n        } else if (keyPressed.name === 'z') {\n          // Prepare to suspend.\n\n          // NOTE: Switch the raw mode off before suspending (needed to make the keypress event\n          // to work correctly when the nodejs process is resumed).\n          setRawMode(stdin, false);\n\n          log.info('\\nweb-ext has been suspended on user request');\n          kill(process.pid, 'SIGTSTP');\n\n          // Prepare to resume.\n\n          log.info(`\\nweb-ext has been resumed. ${keypressUsageInfo}`);\n\n          // Switch the raw mode on on resume.\n          setRawMode(stdin, true);\n        } else if (keyPressed.name === 'r') {\n          log.debug('Reloading installed extensions on user request');\n          extensionRunner.reloadAllExtensions();\n        }\n      }\n\n      log.info('\\nExiting web-ext on user request');\n      extensionRunner.exit();\n    });\n  }\n}\n","/* @flow */\nimport nodeFs from 'fs';\nimport path from 'path';\nimport {promisify} from 'util';\n\nimport {default as defaultFxRunner} from 'fx-runner';\nimport FirefoxProfile, {copyFromUserProfile as defaultUserProfileCopier}\n  from 'firefox-profile';\nimport {fs} from 'mz';\nimport eventToPromise from 'event-to-promise';\n\nimport isDirectory from '../util/is-directory';\nimport {isErrorWithCode, UsageError, WebExtError} from '../errors';\nimport {getPrefs as defaultPrefGetter} from './preferences';\nimport {getManifestId} from '../util/manifest';\nimport {createLogger} from '../util/logger';\nimport {connect as defaultFirefoxConnector, REMOTE_PORT} from './remote';\n// Import flow types\nimport type {FirefoxConnectorFn} from './remote';\nimport type {\n  PreferencesAppName,\n  PreferencesGetterFn,\n  FirefoxPreferences,\n} from './preferences';\nimport type {ExtensionManifest} from '../util/manifest';\n\n\nconst log = createLogger(__filename);\n\nconst defaultAsyncFsStat = fs.stat.bind(fs);\n\nexport const defaultFirefoxEnv = {\n  XPCOM_DEBUG_BREAK: 'stack',\n  NS_TRACE_MALLOC_DISABLE_STACKS: '1',\n};\n\n// defaultRemotePortFinder types and implementation.\n\nexport type RemotePortFinderParams = {|\n  portToTry?: number,\n  retriesLeft?: number,\n  connectToFirefox?: FirefoxConnectorFn,\n|};\n\nexport type RemotePortFinderFn =\n  (params?: RemotePortFinderParams) => Promise<number>;\n\nexport async function defaultRemotePortFinder(\n  {\n    portToTry = REMOTE_PORT,\n    retriesLeft = 10,\n    connectToFirefox = defaultFirefoxConnector,\n  }: RemotePortFinderParams = {}\n): Promise<number> {\n  log.debug(`Checking if remote Firefox port ${portToTry} is available`);\n\n  let client;\n\n  while (retriesLeft >= 0) {\n    try {\n      client = await connectToFirefox(portToTry);\n      log.debug(`Remote Firefox port ${portToTry} is in use ` +\n                `(retries remaining: ${retriesLeft})`);\n    } catch (error) {\n      if (isErrorWithCode('ECONNREFUSED', error)) {\n        // The connection was refused so this port is good to use.\n        return portToTry;\n      }\n\n      throw error;\n    }\n\n    client.disconnect();\n    portToTry++;\n    retriesLeft--;\n  }\n\n  throw new WebExtError('Too many retries on port search');\n}\n\n\n// Declare the needed 'fx-runner' module flow types.\n\nexport type FirefoxRunnerParams = {|\n  binary: ?string,\n  profile?: string,\n  'new-instance'?: boolean,\n  'no-remote'?: boolean,\n  'foreground'?: boolean,\n  'listen': number,\n  'binary-args'?: Array<string> | string,\n  'env'?: {\n    [key: string]: string\n  },\n  'verbose'?: boolean,\n|};\n\nexport interface FirefoxProcess extends events$EventEmitter {\n  stderr: events$EventEmitter;\n  stdout: events$EventEmitter;\n  kill: Function;\n}\n\nexport type FirefoxRunnerResults = {|\n  process: FirefoxProcess,\n  binary: string,\n  args: Array<string>,\n|}\n\nexport type FirefoxRunnerFn =\n  (params: FirefoxRunnerParams) => Promise<FirefoxRunnerResults>;\n\n\nexport type FirefoxInfo = {|\n  firefox: FirefoxProcess,\n  debuggerPort: number,\n|}\n\n// Run command types and implementaion.\n\nexport type FirefoxRunOptions = {|\n  fxRunner?: FirefoxRunnerFn,\n  findRemotePort?: RemotePortFinderFn,\n  firefoxBinary?: string,\n  binaryArgs?: Array<string>,\n  args?: Array<any>,\n|};\n\n/*\n * Runs Firefox with the given profile object and resolves a promise on exit.\n */\nexport async function run(\n  profile: FirefoxProfile,\n  {\n    fxRunner = defaultFxRunner,\n    findRemotePort = defaultRemotePortFinder,\n    firefoxBinary, binaryArgs,\n  }: FirefoxRunOptions = {}\n): Promise<FirefoxInfo> {\n\n  log.debug(`Running Firefox with profile at ${profile.path()}`);\n\n  const remotePort = await findRemotePort();\n\n  const results = await fxRunner({\n    // if this is falsey, fxRunner tries to find the default one.\n    'binary': firefoxBinary,\n    'binary-args': binaryArgs,\n    // This ensures a new instance of Firefox is created. It has nothing\n    // to do with the devtools remote debugger.\n    'no-remote': true,\n    'listen': remotePort,\n    'foreground': true,\n    'profile': profile.path(),\n    'env': {\n      ...process.env,\n      ...defaultFirefoxEnv,\n    },\n    'verbose': true,\n  });\n\n  const firefox = results.process;\n\n  log.debug(`Executing Firefox binary: ${results.binary}`);\n  log.debug(`Firefox args: ${results.args.join(' ')}`);\n\n  firefox.on('error', (error) => {\n    // TODO: show a nice error when it can't find Firefox.\n    // if (/No such file/.test(err) || err.code === 'ENOENT') {\n    log.error(`Firefox error: ${error}`);\n    throw error;\n  });\n\n  log.info(\n    'Use --verbose or open Tools > Web Developer > Browser Console ' +\n    'to see logging');\n\n  firefox.stderr.on('data', (data) => {\n    log.debug(`Firefox stderr: ${data.toString().trim()}`);\n  });\n\n  firefox.stdout.on('data', (data) => {\n    log.debug(`Firefox stdout: ${data.toString().trim()}`);\n  });\n\n  firefox.on('close', () => {\n    log.debug('Firefox closed');\n  });\n\n  return { firefox, debuggerPort: remotePort };\n}\n\n\n// isDefaultProfile types and implementation.\n\nconst DEFAULT_PROFILES_NAMES = [\n  'default',\n  'dev-edition-default',\n];\n\nexport type IsDefaultProfileFn = (\n  profilePathOrName: string,\n  ProfileFinder?: typeof FirefoxProfile.Finder,\n  fsStat?: typeof fs.stat,\n) => Promise<boolean>;\n\n/*\n * Tests if a profile is a default Firefox profile (both as a profile name or\n * profile path).\n *\n * Returns a promise that resolves to true if the profile is one of default Firefox profile.\n */\nexport async function isDefaultProfile(\n  profilePathOrName: string,\n  ProfileFinder?: typeof FirefoxProfile.Finder = FirefoxProfile.Finder,\n  fsStat?: typeof fs.stat = fs.stat,\n): Promise<boolean> {\n  if (DEFAULT_PROFILES_NAMES.includes(profilePathOrName)) {\n    return true;\n  }\n\n  const baseProfileDir = ProfileFinder.locateUserDirectory();\n  const profilesIniPath = path.join(baseProfileDir, 'profiles.ini');\n  try {\n    await fsStat(profilesIniPath);\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error)) {\n      log.debug(`profiles.ini not found: ${error}`);\n\n      // No profiles exist yet, default to false (the default profile name contains a\n      // random generated component).\n      return false;\n    }\n\n    // Re-throw any unexpected exception.\n    throw error;\n  }\n\n  // Check for profile dir path.\n  const finder = new ProfileFinder(baseProfileDir);\n  const readProfiles = promisify(finder.readProfiles.bind(finder));\n\n  await readProfiles();\n\n  const normalizedProfileDirPath = path.normalize(\n    path.join(path.resolve(profilePathOrName), path.sep)\n  );\n\n  for (const profile of finder.profiles) {\n    // Check if the profile dir path or name is one of the default profiles\n    // defined in the profiles.ini file.\n    if (DEFAULT_PROFILES_NAMES.includes(profile.Name) ||\n        profile.Default === '1') {\n      let profileFullPath;\n\n      // Check for profile name.\n      if (profile.Name === profilePathOrName) {\n        return true;\n      }\n\n      // Check for profile path.\n      if (profile.IsRelative === '1') {\n        profileFullPath = path.join(baseProfileDir, profile.Path, path.sep);\n      } else {\n        profileFullPath = path.join(profile.Path, path.sep);\n      }\n\n      if (path.normalize(profileFullPath) === normalizedProfileDirPath) {\n        return true;\n      }\n    }\n  }\n\n  // Profile directory not found.\n  return false;\n}\n\n// configureProfile types and implementation.\n\nexport type ConfigureProfileOptions = {|\n  app?: PreferencesAppName,\n  getPrefs?: PreferencesGetterFn,\n  customPrefs?: FirefoxPreferences,\n|};\n\nexport type ConfigureProfileFn = (\n  profile: FirefoxProfile,\n  options?: ConfigureProfileOptions\n) => Promise<FirefoxProfile>;\n\n/*\n * Configures a profile with common preferences that are required to\n * activate extension development.\n *\n * Returns a promise that resolves with the original profile object.\n */\nexport function configureProfile(\n  profile: FirefoxProfile,\n  {\n    app = 'firefox',\n    getPrefs = defaultPrefGetter,\n    customPrefs = {},\n  }: ConfigureProfileOptions = {},\n): Promise<FirefoxProfile> {\n  // Set default preferences. Some of these are required for the add-on to\n  // operate, such as disabling signatures.\n  const prefs = getPrefs(app);\n  Object.keys(prefs).forEach((pref) => {\n    profile.setPreference(pref, prefs[pref]);\n  });\n  if (Object.keys(customPrefs).length > 0) {\n    const customPrefsStr = JSON.stringify(customPrefs, null, 2);\n    log.info(`Setting custom Firefox preferences: ${customPrefsStr}`);\n    Object.keys(customPrefs).forEach((custom) => {\n      profile.setPreference(custom, customPrefs[custom]);\n    });\n  }\n  profile.updatePreferences();\n  return Promise.resolve(profile);\n}\n\nexport type getProfileFn = (profileName: string) => Promise<string | void>;\n\nexport type CreateProfileFinderParams = {|\n  userDirectoryPath?: string,\n  FxProfile?: typeof FirefoxProfile\n|}\n\nexport function defaultCreateProfileFinder(\n  {\n    userDirectoryPath,\n    FxProfile = FirefoxProfile,\n  }: CreateProfileFinderParams = {}\n): getProfileFn {\n  const finder = new FxProfile.Finder(userDirectoryPath);\n  const readProfiles = promisify(finder.readProfiles.bind(finder));\n  const getPath = promisify(finder.getPath.bind(finder));\n  return async (profileName: string): Promise<string | void> => {\n    try {\n      await readProfiles();\n      const hasProfileName = finder.profiles.filter(\n        (profileDef) => profileDef.Name === profileName).length !== 0;\n      if (hasProfileName) {\n        return await getPath(profileName);\n      }\n    } catch (error) {\n      if (!isErrorWithCode('ENOENT', error)) {\n        throw error;\n      }\n      log.warn('Unable to find Firefox profiles.ini');\n    }\n  };\n}\n\n// useProfile types and implementation.\n\nexport type UseProfileParams = {\n  app?: PreferencesAppName,\n  configureThisProfile?: ConfigureProfileFn,\n  isFirefoxDefaultProfile?: IsDefaultProfileFn,\n  customPrefs?: FirefoxPreferences,\n  createProfileFinder?: typeof defaultCreateProfileFinder,\n};\n\n// Use the target path as a Firefox profile without cloning it\n\nexport async function useProfile(\n  profilePath: string,\n  {\n    app,\n    configureThisProfile = configureProfile,\n    isFirefoxDefaultProfile = isDefaultProfile,\n    customPrefs = {},\n    createProfileFinder = defaultCreateProfileFinder,\n  }: UseProfileParams = {},\n): Promise<FirefoxProfile> {\n  const isForbiddenProfile = await isFirefoxDefaultProfile(profilePath);\n  if (isForbiddenProfile) {\n    throw new UsageError(\n      'Cannot use --keep-profile-changes on a default profile' +\n      ` (\"${profilePath}\")` +\n      ' because web-ext will make it insecure and unsuitable for daily use.' +\n      '\\nSee https://github.com/mozilla/web-ext/issues/1005'\n    );\n  }\n\n  let destinationDirectory;\n  const getProfilePath = createProfileFinder();\n\n  const profileIsDirPath = await isDirectory(profilePath);\n  if (profileIsDirPath) {\n    log.debug(`Using profile directory \"${profilePath}\"`);\n    destinationDirectory = profilePath;\n  } else {\n    log.debug(`Assuming ${profilePath} is a named profile`);\n    destinationDirectory = await getProfilePath(profilePath);\n    if (!destinationDirectory) {\n      throw new UsageError(\n        `The request \"${profilePath}\" profile name ` +\n        'cannot be resolved to a profile path'\n      );\n    }\n  }\n\n  const profile = new FirefoxProfile({destinationDirectory});\n  return await configureThisProfile(profile, {app, customPrefs});\n}\n\n\n// createProfile types and implementation.\n\nexport type CreateProfileParams = {\n  app?: PreferencesAppName,\n  configureThisProfile?: ConfigureProfileFn,\n  customPrefs?: FirefoxPreferences,\n};\n\n/*\n * Creates a new temporary profile and resolves with the profile object.\n *\n * The profile will be deleted when the system process exits.\n */\nexport async function createProfile(\n  {\n    app,\n    configureThisProfile = configureProfile,\n    customPrefs = {},\n  }: CreateProfileParams = {},\n): Promise<FirefoxProfile> {\n  const profile = new FirefoxProfile();\n  return await configureThisProfile(profile, {app, customPrefs});\n}\n\n\n// copyProfile types and implementation.\n\nexport type CopyProfileOptions = {|\n  app?: PreferencesAppName,\n  configureThisProfile?: ConfigureProfileFn,\n  copyFromUserProfile?: Function,\n  customPrefs?: FirefoxPreferences,\n|};\n\n/*\n * Copies an existing Firefox profile and creates a new temporary profile.\n * The new profile will be configured with some preferences required to\n * activate extension development.\n *\n * It resolves with the new profile object.\n *\n * The temporary profile will be deleted when the system process exits.\n *\n * The existing profile can be specified as a directory path or a name of\n * one that exists in the current user's Firefox directory.\n */\nexport async function copyProfile(\n  profileDirectory: string,\n  {\n    app,\n    configureThisProfile = configureProfile,\n    copyFromUserProfile = defaultUserProfileCopier,\n    customPrefs = {},\n  }: CopyProfileOptions = {},\n): Promise<FirefoxProfile> {\n\n  const copy = promisify(FirefoxProfile.copy);\n  const copyByName = promisify(copyFromUserProfile);\n\n  try {\n    const dirExists = await isDirectory(profileDirectory);\n\n    let profile;\n\n    if (dirExists) {\n      log.debug(`Copying profile directory from \"${profileDirectory}\"`);\n      profile = await copy({profileDirectory});\n    } else {\n      log.debug(`Assuming ${profileDirectory} is a named profile`);\n      profile = await copyByName({name: profileDirectory});\n    }\n\n    return configureThisProfile(profile, {app, customPrefs});\n  } catch (error) {\n    throw new WebExtError(\n      `Could not copy Firefox profile from ${profileDirectory}: ${error}`);\n  }\n}\n\n\n// installExtension types and implementation.\n\nexport type InstallExtensionParams = {|\n  asProxy?: boolean,\n  manifestData: ExtensionManifest,\n  profile: FirefoxProfile,\n  extensionPath: string,\n  asyncFsStat?: typeof defaultAsyncFsStat,\n|};\n\n/*\n * Installs an extension into the given Firefox profile object.\n * Resolves when complete.\n *\n * The extension is copied into a special location and you need to turn\n * on some preferences to allow this. See extensions.autoDisableScopes in\n * ./preferences.js.\n *\n * When asProxy is true, a special proxy file will be installed. This is a\n * text file that contains the path to the extension source.\n */\nexport async function installExtension(\n  {\n    asProxy = false,\n    manifestData,\n    profile,\n    extensionPath,\n    asyncFsStat = defaultAsyncFsStat,\n  }: InstallExtensionParams): Promise<any> {\n  // This more or less follows\n  // https://github.com/saadtazi/firefox-profile-js/blob/master/lib/firefox_profile.js#L531\n  // (which is broken for web extensions).\n  // TODO: maybe uplift a patch that supports web extensions instead?\n\n  if (!profile.extensionsDir) {\n    throw new WebExtError('profile.extensionsDir was unexpectedly empty');\n  }\n\n  try {\n    await asyncFsStat(profile.extensionsDir);\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error)) {\n      log.debug(`Creating extensions directory: ${profile.extensionsDir}`);\n      await fs.mkdir(profile.extensionsDir);\n    } else {\n      throw error;\n    }\n  }\n\n  const id = getManifestId(manifestData);\n  if (!id) {\n    throw new UsageError(\n      'An explicit extension ID is required when installing to ' +\n      'a profile (applications.gecko.id not found in manifest.json)');\n  }\n\n  if (asProxy) {\n    log.debug(`Installing as an extension proxy; source: ${extensionPath}`);\n\n    const isDir = await isDirectory(extensionPath);\n    if (!isDir) {\n      throw new WebExtError(\n        'proxy install: extensionPath must be the extension source ' +\n        `directory; got: ${extensionPath}`);\n    }\n\n    // Write a special extension proxy file containing the source\n    // directory. See:\n    // https://developer.mozilla.org/en-US/Add-ons/Setting_up_extension_development_environment#Firefox_extension_proxy_file\n    const destPath = path.join(profile.extensionsDir, `${id}`);\n    const writeStream = nodeFs.createWriteStream(destPath);\n    writeStream.write(extensionPath);\n    writeStream.end();\n    return await eventToPromise(writeStream, 'close');\n  } else {\n    // Write the XPI file to the profile.\n    const readStream = nodeFs.createReadStream(extensionPath);\n    const destPath = path.join(profile.extensionsDir, `${id}.xpi`);\n    const writeStream = nodeFs.createWriteStream(destPath);\n\n    log.debug(`Installing extension from ${extensionPath} to ${destPath}`);\n    readStream.pipe(writeStream);\n\n    return await Promise.all([\n      eventToPromise(readStream, 'close'),\n      eventToPromise(writeStream, 'close'),\n    ]);\n  }\n}\n","module.exports = require(\"os\");","/* @flow */\n\nimport type {\n  BuildCmdParams, BuildCmdOptions, ExtensionBuildResult,\n} from './build';\nimport type {LintCmdParams, LintCmdOptions} from './lint';\nimport type {CmdRunParams, CmdRunOptions} from './run';\nimport type {MultiExtensionRunner} from '../extension-runners';\nimport type {SignParams, SignOptions, SignResult} from './sign';\nimport type {DocsParams, DocsOptions} from './docs';\n\n// This module exports entry points for all supported commands. For performance\n// reasons (faster start-up), the implementations are not statically imported\n// at the top of the file, but lazily loaded in the (exported) functions.\n// The latter would slow down start-up by several seconds, as seen in #1302 .\n\nasync function build(\n  params: BuildCmdParams, options: BuildCmdOptions\n): Promise<ExtensionBuildResult> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./build');\n  return runCommand(params, options);\n}\n\nasync function lint(\n  params: LintCmdParams, options: LintCmdOptions\n): Promise<void> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./lint');\n  return runCommand(params, options);\n}\n\nasync function run(\n  params: CmdRunParams, options: CmdRunOptions\n): Promise<MultiExtensionRunner> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./run');\n  return runCommand(params, options);\n}\n\nasync function sign(\n  params: SignParams, options: SignOptions\n): Promise<SignResult> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./sign');\n  return runCommand(params, options);\n}\n\nasync function docs(\n  params: DocsParams, options: DocsOptions\n): Promise<void> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./docs');\n  return runCommand(params, options);\n}\n\nexport default {build, lint, run, sign, docs};\n","module.exports = require(\"parse-json\");","module.exports = require(\"strip-json-comments\");","/* @flow */\nimport Watchpack from 'watchpack';\nimport debounce from 'debounce';\n\nimport {createLogger} from './util/logger';\n\n\nconst log = createLogger(__filename);\n\n\n// onSourceChange types and implementation\n\nexport type ShouldWatchFn = (filePath: string) => boolean;\n\nexport type OnChangeFn = () => any;\n\nexport type OnSourceChangeParams = {|\n  sourceDir: string,\n  artifactsDir: string,\n  onChange: OnChangeFn,\n  shouldWatchFile: ShouldWatchFn,\n|};\n\n// NOTE: this fix an issue with flow and default exports (which currently\n// lose their type signatures) by explicitly declare the default export\n// signature. Reference: https://github.com/facebook/flow/issues/449\n// eslint-disable-next-line no-shadow\ndeclare function exports(params: OnSourceChangeParams): Watchpack;\n\nexport type OnSourceChangeFn = (params: OnSourceChangeParams) => Watchpack;\n\nexport default function onSourceChange(\n  {sourceDir, artifactsDir, onChange, shouldWatchFile}: OnSourceChangeParams\n): Watchpack {\n  // TODO: For network disks, we would need to add {poll: true}.\n  const watcher = new Watchpack();\n\n  const executeImmediately = true;\n  onChange = debounce(onChange, 1000, executeImmediately);\n\n  watcher.on('change', (filePath) => {\n    proxyFileChanges({artifactsDir, onChange, filePath, shouldWatchFile});\n  });\n\n  log.debug(`Watching for file changes in ${sourceDir}`);\n  watcher.watch([], [sourceDir], Date.now());\n\n  // TODO: support interrupting the watcher on Windows.\n  // https://github.com/mozilla/web-ext/issues/225\n  process.on('SIGINT', () => watcher.close());\n  return watcher;\n}\n\n\n// proxyFileChanges types and implementation.\n\nexport type ProxyFileChangesParams = {|\n  artifactsDir: string,\n  onChange: OnChangeFn,\n  filePath: string,\n  shouldWatchFile: ShouldWatchFn,\n|};\n\nexport function proxyFileChanges(\n  {artifactsDir, onChange, filePath, shouldWatchFile}: ProxyFileChangesParams\n): void {\n  if (filePath.indexOf(artifactsDir) === 0 || !shouldWatchFile(filePath)) {\n    log.debug(`Ignoring change to: ${filePath}`);\n  } else {\n    log.debug(`Changed: ${filePath}`);\n    log.debug(`Last change detection: ${(new Date()).toTimeString()}`);\n    onChange();\n  }\n}\n","/* @flow */\nimport {promisify} from 'util';\n\nimport {fs} from 'mz';\nimport mkdirp from 'mkdirp';\n\nimport {UsageError, isErrorWithCode} from '../errors';\nimport {createLogger} from './logger';\n\nconst log = createLogger(__filename);\n\nconst defaultAsyncMkdirp = promisify(mkdirp);\nconst defaultAsyncFsAccess = fs.access.bind(fs);\n\ntype PrepareArtifactsDirOptions = {\n  asyncMkdirp?: typeof defaultAsyncMkdirp,\n  asyncFsAccess?: typeof defaultAsyncFsAccess,\n}\n\nexport async function prepareArtifactsDir(\n  artifactsDir: string,\n  {\n    asyncMkdirp = defaultAsyncMkdirp,\n    asyncFsAccess = defaultAsyncFsAccess,\n  }: PrepareArtifactsDirOptions = {},\n): Promise<string> {\n  try {\n    const stats = await fs.stat(artifactsDir);\n    if (!stats.isDirectory()) {\n      throw new UsageError(\n        `--artifacts-dir=\"${artifactsDir}\" exists but it is not a directory.`);\n    }\n    // If the artifactsDir already exists, check that we have the write permissions on it.\n    try {\n      await asyncFsAccess(artifactsDir, fs.W_OK);\n    } catch (accessErr) {\n      if (isErrorWithCode('EACCES', accessErr)) {\n        throw new UsageError(\n          `--artifacts-dir=\"${artifactsDir}\" exists but the user lacks ` +\n          'permissions on it.');\n      } else {\n        throw accessErr;\n      }\n    }\n  } catch (error) {\n    if (isErrorWithCode('EACCES', error)) {\n      // Handle errors when the artifactsDir cannot be accessed.\n      throw new UsageError(\n        `Cannot access --artifacts-dir=\"${artifactsDir}\" because the user ` +\n        `lacks permissions: ${error}`);\n    } else if (isErrorWithCode('ENOENT', error)) {\n      // Create the artifact dir if it doesn't exist yet.\n      try {\n        log.debug(`Creating artifacts directory: ${artifactsDir}`);\n        await asyncMkdirp(artifactsDir);\n      } catch (mkdirErr) {\n        if (isErrorWithCode('EACCES', mkdirErr)) {\n          // Handle errors when the artifactsDir cannot be created for lack of permissions.\n          throw new UsageError(\n            `Cannot create --artifacts-dir=\"${artifactsDir}\" because the ` +\n            `user lacks permissions: ${mkdirErr}`);\n        } else {\n          throw mkdirErr;\n        }\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  return artifactsDir;\n}\n","/* @flow */\nimport {WebExtError, UsageError} from '../errors';\nimport {createLogger} from '../util/logger';\n\nconst log = createLogger(__filename);\nexport const nonOverridablePreferences = [\n  'devtools.debugger.remote-enabled', 'devtools.debugger.prompt-connection',\n  'xpinstall.signatures.required',\n];\n\n// Flow Types\n\nexport type FirefoxPreferences = {\n  [key: string]: boolean | string | number,\n};\n\nexport type PreferencesAppName = 'firefox' | 'fennec';\n\n\n// Preferences Maps\n\nconst prefsCommon: FirefoxPreferences = {\n  // Allow debug output via dump to be printed to the system console\n  'browser.dom.window.dump.enabled': true,\n\n  // Allow remote connections to the debugger.\n  'devtools.debugger.remote-enabled': true,\n  // Disable the prompt for allowing connections.\n  'devtools.debugger.prompt-connection': false,\n\n  // Turn off platform logging because it is a lot of info.\n  'extensions.logging.enabled': false,\n\n  // Disable extension updates and notifications.\n  'extensions.checkCompatibility.nightly': false,\n  'extensions.update.enabled': false,\n  'extensions.update.notifyUser': false,\n\n  // From:\n  // http://hg.mozilla.org/mozilla-central/file/1dd81c324ac7/build/automation.py.in//l372\n  // Only load extensions from the application and user profile.\n  // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION\n  'extensions.enabledScopes': 5,\n  // Disable metadata caching for installed add-ons by default.\n  'extensions.getAddons.cache.enabled': false,\n  // Disable intalling any distribution add-ons.\n  'extensions.installDistroAddons': false,\n  // Allow installing extensions dropped into the profile folder.\n  'extensions.autoDisableScopes': 10,\n\n  // Disable app update.\n  'app.update.enabled': false,\n\n  // Allow unsigned add-ons.\n  'xpinstall.signatures.required': false,\n};\n\n// Prefs specific to Firefox for Android.\nconst prefsFennec: FirefoxPreferences = {\n  'browser.console.showInPanel': true,\n  'browser.firstrun.show.uidiscovery': false,\n  // browser.link.open_newwindow is changed from 3 to 2 in:\n  // https://github.com/saadtazi/firefox-profile-js/blob/cafc793d940a779d280103ae17d02a92de862efc/lib/firefox_profile.js#L32\n  // Restore original value to avoid https://github.com/mozilla/web-ext/issues/1592\n  'browser.link.open_newwindow': 3,\n  'devtools.remote.usb.enabled': true,\n};\n\n// Prefs specific to Firefox for desktop.\nconst prefsFirefox: FirefoxPreferences = {\n  'browser.startup.homepage': 'about:blank',\n  'startup.homepage_welcome_url': 'about:blank',\n  'startup.homepage_welcome_url.additional': '',\n  'devtools.errorconsole.enabled': true,\n  'devtools.chrome.enabled': true,\n\n  // From:\n  // http://hg.mozilla.org/mozilla-central/file/1dd81c324ac7/build/automation.py.in//l388\n  // Make url-classifier updates so rare that they won't affect tests.\n  'urlclassifier.updateinterval': 172800,\n  // Point the url-classifier to a nonexistent local URL for fast failures.\n  'browser.safebrowsing.provider.0.gethashURL':\n    'http://localhost/safebrowsing-dummy/gethash',\n  'browser.safebrowsing.provider.0.keyURL':\n    'http://localhost/safebrowsing-dummy/newkey',\n  'browser.safebrowsing.provider.0.updateURL':\n    'http://localhost/safebrowsing-dummy/update',\n\n  // Disable self repair/SHIELD\n  'browser.selfsupport.url': 'https://localhost/selfrepair',\n  // Disable Reader Mode UI tour\n  'browser.reader.detectedFirstArticle': true,\n\n  // Set the policy firstURL to an empty string to prevent\n  // the privacy info page to be opened on every \"web-ext run\".\n  // (See #1114 for rationale)\n  'datareporting.policy.firstRunURL': '',\n};\n\nconst prefs = {\n  common: prefsCommon,\n  fennec: prefsFennec,\n  firefox: prefsFirefox,\n};\n\n\n// Module exports\n\nexport type PreferencesGetterFn =\n  (appName: PreferencesAppName) => FirefoxPreferences;\n\nexport function getPrefs(\n  app: PreferencesAppName = 'firefox'\n): FirefoxPreferences {\n  const appPrefs = prefs[app];\n  if (!appPrefs) {\n    throw new WebExtError(`Unsupported application: ${app}`);\n  }\n  return {\n    ...prefsCommon,\n    ...appPrefs,\n  };\n}\n\nexport function coerceCLICustomPreference(\n  cliPrefs: Array<string>\n): FirefoxPreferences {\n  const customPrefs = {};\n\n  for (const pref of cliPrefs) {\n    const prefsAry = pref.split('=');\n\n    if (prefsAry.length < 2) {\n      throw new UsageError(\n        `Incomplete custom preference: \"${pref}\". ` +\n        'Syntax expected: \"prefname=prefvalue\".'\n      );\n    }\n\n    const key = prefsAry[0];\n    let value = prefsAry.slice(1).join('=');\n\n    if (/[^\\w{@}.-]/.test(key)) {\n      throw new UsageError(`Invalid custom preference name: ${key}`);\n    }\n\n    if (value === `${parseInt(value)}`) {\n      value = parseInt(value, 10);\n    } else if (value === 'true' || value === 'false') {\n      value = (value === 'true');\n    }\n\n    if (nonOverridablePreferences.includes(key)) {\n      log.warn(`'${key}' preference cannot be customized.`);\n      continue;\n    }\n    customPrefs[`${key}`] = value;\n  }\n\n  return customPrefs;\n}\n","module.exports = require(\"readline\");","/* @flow */\nimport {promisify} from 'util';\n\nimport tmp from 'tmp';\n\nimport {createLogger} from './logger';\nimport {multiArgsPromisedFn} from './promisify';\n\nconst log = createLogger(__filename);\n\nexport type MakePromiseCallback = (tmpDir: TempDir) => any;\n\ntmp.dir[promisify.custom] = multiArgsPromisedFn(tmp.dir);\n\nconst createTempDir = promisify(tmp.dir);\n\n/*\n * Work with a self-destructing temporary directory in a promise chain.\n *\n * The directory will be destroyed when the promise chain is finished\n * (whether there was an error or not).\n *\n * Usage:\n *\n * withTempDir(\n *   (tmpDir) =>\n *     doSomething(tmpDir.path())\n *     .then(...)\n * );\n *\n */\nexport function withTempDir(makePromise: MakePromiseCallback): Promise<any> {\n  const tmpDir = new TempDir();\n  return tmpDir.create()\n    .then(() => {\n      return makePromise(tmpDir);\n    })\n    .catch(tmpDir.errorHandler())\n    .then(tmpDir.successHandler());\n}\n\n/*\n * Work with a self-destructing temporary directory object.\n *\n * It is safer to use withTempDir() instead but if you know\n * what you're doing you can use it directly like:\n *\n * let tmpDir = new TempDir();\n * tmpDir.create()\n *   .then(() => {\n *     // work with tmpDir.path()\n *   })\n *   .catch(tmpDir.errorHandler())\n *   .then(tmpDir.successHandler());\n *\n */\nexport class TempDir {\n  _path: string | void;\n  _removeTempDir: Function | void;\n\n  constructor() {\n    this._path = undefined;\n    this._removeTempDir = undefined;\n  }\n\n  /*\n   * Returns a promise that is fulfilled when the temp directory has\n   * been created.\n   */\n  create(): Promise<TempDir> {\n    return createTempDir(\n      {\n        prefix: 'tmp-web-ext-',\n        // This allows us to remove a non-empty tmp dir.\n        unsafeCleanup: true,\n      })\n      .then(([tmpPath, removeTempDir]) => {\n        this._path = tmpPath;\n        this._removeTempDir = () => new Promise((resolve, reject) => {\n          // `removeTempDir` parameter is a `next` callback which\n          // is called once the dir has been removed.\n          const next = (err) => err ? reject(err) : resolve();\n          removeTempDir(next);\n        });\n        log.debug(`Created temporary directory: ${this.path()}`);\n        return this;\n      });\n  }\n\n  /*\n   * Get the absolute path of the temp directory.\n   */\n  path(): string {\n    if (!this._path) {\n      throw new Error('You cannot access path() before calling create()');\n    }\n    return this._path;\n  }\n\n  /*\n   * Returns a callback that will catch an error, remove\n   * the temporary directory, and throw the error.\n   *\n   * This is intended for use in a promise like\n   * Promise().catch(tmp.errorHandler())\n   */\n  errorHandler(): Function {\n    return async (error) => {\n      await this.remove();\n      throw error;\n    };\n  }\n\n  /*\n   * Returns a callback that will remove the temporary direcotry.\n   *\n   * This is intended for use in a promise like\n   * Promise().then(tmp.successHandler())\n   */\n  successHandler(): Function {\n    return async (promiseResult) => {\n      await this.remove();\n      return promiseResult;\n    };\n  }\n\n  /*\n   * Remove the temp directory.\n   */\n  remove() {\n    if (!this._removeTempDir) {\n      return;\n    }\n    log.debug(`Removing temporary directory: ${this.path()}`);\n    return this._removeTempDir && this._removeTempDir();\n  }\n\n}\n","/* @flow */\nimport {fs} from 'mz';\n\nimport {onlyErrorsWithCode} from '../errors';\n\n/*\n * Resolves true if the path is a readable directory.\n *\n * Usage:\n *\n * isDirectory('/some/path')\n *  .then((dirExists) => {\n *    // dirExists will be true or false.\n *  });\n *\n * */\nexport default function isDirectory(path: string): Promise<boolean> {\n  return fs.stat(path)\n    .then((stats) => stats.isDirectory())\n    .catch(onlyErrorsWithCode(['ENOENT', 'ENOTDIR'], () => {\n      return false;\n    }));\n}\n","module.exports = require(\"tmp\");","/* @flow */\nimport os from 'os';\nimport path from 'path';\n\nimport requireUncached from 'require-uncached';\nimport camelCase from 'camelcase';\nimport decamelize from 'decamelize';\n\nimport fileExists from './util/file-exists';\nimport {createLogger} from './util/logger';\nimport {UsageError, WebExtError} from './errors';\n\nconst log = createLogger(__filename);\n\ntype ApplyConfigToArgvParams = {|\n  // This is the argv object which will get updated by each\n  // config applied.\n  argv: Object,\n  // This is the argv that only has CLI values applied to it.\n  argvFromCLI: Object,\n  configObject: Object,\n  options: Object,\n  configFileName: string,\n|};\n\nexport function applyConfigToArgv({\n  argv,\n  argvFromCLI,\n  configObject,\n  options,\n  configFileName,\n}: ApplyConfigToArgvParams): Object {\n  let newArgv = {...argv};\n\n  for (const option of Object.keys(configObject)) {\n    if (camelCase(option) !== option) {\n      throw new UsageError(\n        `The config option \"${option}\" must be ` +\n        `specified in camel case: \"${camelCase(option)}\"`);\n    }\n\n    // A config option cannot be a sub-command config\n    // object if it is an array.\n    if (!Array.isArray(configObject[option]) &&\n      typeof options[option] === 'object' &&\n      typeof configObject[option] === 'object') {\n      // Descend into the nested configuration for a sub-command.\n      newArgv = applyConfigToArgv({\n        argv: newArgv,\n        argvFromCLI,\n        configObject: configObject[option],\n        options: options[option],\n        configFileName});\n      continue;\n    }\n\n    const decamelizedOptName = decamelize(option, '-');\n\n    if (typeof options[decamelizedOptName] !== 'object') {\n      throw new UsageError(`The config file at ${configFileName} specified ` +\n        `an unknown option: \"${option}\"`);\n    }\n    if (options[decamelizedOptName].type === undefined) {\n      // This means yargs option type wasn't not defined correctly\n      throw new WebExtError(\n        `Option: ${option} was defined without a type.`);\n    }\n\n    const expectedType = options[decamelizedOptName].type ===\n      'count' ? 'number' : options[decamelizedOptName].type;\n\n    const optionType = (\n      Array.isArray(configObject[option]) ?\n        'array' : typeof configObject[option]\n    );\n\n    if (optionType !== expectedType) {\n      throw new UsageError(`The config file at ${configFileName} specified ` +\n        `the type of \"${option}\" incorrectly as \"${optionType}\"` +\n        ` (expected type \"${expectedType}\")`);\n    }\n\n    let defaultValue;\n    if (options[decamelizedOptName]) {\n      if (options[decamelizedOptName].default !== undefined) {\n        defaultValue = options[decamelizedOptName].default;\n      } else if (expectedType === 'boolean') {\n        defaultValue = false;\n      }\n    }\n\n    // This is our best effort (without patching yargs) to detect\n    // if a value was set on the CLI instead of in the config.\n    // It looks for a default value and if the argv value is\n    // different, it assumes that the value was configured on the CLI.\n\n    const wasValueSetOnCLI =\n      typeof argvFromCLI[option] !== 'undefined' &&\n      argvFromCLI[option] !== defaultValue;\n    if (wasValueSetOnCLI) {\n      log.debug(\n        `Favoring CLI: ${option}=${argvFromCLI[option]} over ` +\n        `configuration: ${option}=${configObject[option]}`);\n      newArgv[option] = argvFromCLI[option];\n      continue;\n    }\n\n    newArgv[option] = configObject[option];\n\n    const coerce = options[decamelizedOptName].coerce;\n    if (coerce) {\n      log.debug(\n        `Calling coerce() on configured value for ${option}`);\n      newArgv[option] = coerce(newArgv[option]);\n    }\n  }\n  return newArgv;\n}\n\nexport function loadJSConfigFile(filePath: string): Object {\n  const resolvedFilePath = path.resolve(filePath);\n  log.debug(\n    `Loading JS config file: \"${filePath}\" ` +\n    `(resolved to \"${resolvedFilePath}\")`);\n  let configObject;\n  try {\n    configObject = requireUncached(resolvedFilePath);\n  } catch (error) {\n    log.debug('Handling error:', error);\n    throw new UsageError(\n      `Cannot read config file: ${resolvedFilePath}\\n` +\n      `Error: ${error.message}`);\n  }\n  if (filePath.endsWith('package.json')) {\n    log.debug('Looking for webExt key inside package.json file');\n    configObject = configObject.webExt || {};\n  }\n  if (Object.keys(configObject).length === 0) {\n    log.debug(`Config file ${resolvedFilePath} did not define any options. ` +\n      'Did you set module.exports = {...}?');\n  }\n  return configObject;\n}\n\ntype DiscoverConfigFilesParams = {|\n  getHomeDir: () => string,\n|};\n\nexport async function discoverConfigFiles(\n  {getHomeDir = os.homedir}: DiscoverConfigFilesParams = {}\n): Promise<Array<string>> {\n  const magicConfigName = 'web-ext-config.js';\n\n  // Config files will be loaded in this order.\n  const possibleConfigs = [\n    // Look for a magic hidden config (preceded by dot) in home dir.\n    path.join(getHomeDir(), `.${magicConfigName}`),\n    // Look for webExt key inside package.json file\n    path.join(process.cwd(), 'package.json'),\n    // Look for a magic config in the current working directory.\n    path.join(process.cwd(), magicConfigName),\n  ];\n\n  const configs = await Promise.all(possibleConfigs.map(\n    async (fileName) => {\n      const resolvedFileName = path.resolve(fileName);\n      if (await fileExists(resolvedFileName)) {\n        return resolvedFileName;\n      } else {\n        log.debug(\n          `Discovered config \"${resolvedFileName}\" does not ` +\n          'exist or is not readable');\n        return undefined;\n      }\n    }\n  ));\n\n  const existingConfigs = [];\n  configs.forEach((f) => {\n    if (typeof f === 'string') {\n      existingConfigs.push(f);\n    }\n  });\n  return existingConfigs;\n}\n","module.exports = require(\"git-rev-sync\");","/* @flow */\nimport os from 'os';\nimport path from 'path';\nimport {readFileSync} from 'fs';\n\nimport camelCase from 'camelcase';\nimport git from 'git-rev-sync';\nimport yargs from 'yargs';\n\nimport defaultCommands from './cmd';\nimport {UsageError} from './errors';\nimport {createLogger, consoleStream as defaultLogStream} from './util/logger';\nimport {coerceCLICustomPreference} from './firefox/preferences';\nimport {checkForUpdates as defaultUpdateChecker} from './util/updates';\nimport {\n  discoverConfigFiles as defaultConfigDiscovery,\n  loadJSConfigFile as defaultLoadJSConfigFile,\n  applyConfigToArgv as defaultApplyConfigToArgv,\n} from './config';\n\nconst log = createLogger(__filename);\nconst envPrefix = 'WEB_EXT';\n\n\ntype ProgramOptions = {|\n  absolutePackageDir?: string,\n|}\n\nexport type VersionGetterFn = (absolutePackageDir: string) => string;\n\n// TODO: add pipes to Flow type after https://github.com/facebook/flow/issues/2405 is fixed\n\ntype ExecuteOptions = {\n  checkForUpdates?: Function,\n  systemProcess?: typeof process,\n  logStream?: typeof defaultLogStream,\n  getVersion?: VersionGetterFn,\n  applyConfigToArgv?: typeof defaultApplyConfigToArgv,\n  discoverConfigFiles?: typeof defaultConfigDiscovery,\n  loadJSConfigFile?: typeof defaultLoadJSConfigFile,\n  shouldExitProgram?: boolean,\n  globalEnv?: string,\n}\n\n\n/*\n * The command line program.\n */\nexport class Program {\n  absolutePackageDir: string;\n  yargs: any;\n  commands: { [key: string]: Function };\n  shouldExitProgram: boolean;\n  verboseEnabled: boolean;\n  options: Object;\n\n  constructor(\n    argv: ?Array<string>,\n    {\n      absolutePackageDir = process.cwd(),\n    }: ProgramOptions = {}\n  ) {\n    // This allows us to override the process argv which is useful for\n    // testing.\n    // NOTE: process.argv.slice(2) removes the path to node and web-ext\n    // executables from the process.argv array.\n    argv = argv || process.argv.slice(2);\n\n    // NOTE: always initialize yargs explicitly with the package dir\n    // to avoid side-effects due to yargs looking for its configuration\n    // section from a package.json file stored in an arbitrary directory\n    // (e.g. in tests yargs would end up loading yargs config from the\n    // mocha package.json). web-ext package.json doesn't contain any yargs\n    // section as it is deprecated and we configure yargs using\n    // yargs.parserConfiguration. See web-ext#469 for rationale.\n    const yargsInstance = yargs(argv, absolutePackageDir);\n\n    this.absolutePackageDir = absolutePackageDir;\n    this.verboseEnabled = false;\n    this.shouldExitProgram = true;\n    this.yargs = yargsInstance;\n\n    // The following yargs configuration option is needed to fix #304.\n    this.yargs.parserConfiguration({\n      'boolean-negation': false,\n    });\n\n    this.yargs.strict();\n\n    this.commands = {};\n    this.options = {};\n  }\n\n  command(\n    name: string, description: string, executor: Function,\n    commandOptions: Object = {}\n  ): Program {\n    this.options[camelCase(name)] = commandOptions;\n\n    this.yargs.command(name, description, (yargsForCmd) => {\n      if (!commandOptions) {\n        return;\n      }\n      return yargsForCmd\n        // Make sure the user does not add any extra commands. For example,\n        // this would be a mistake because lint does not accept arguments:\n        // web-ext lint ./src/path/to/file.js\n        .demandCommand(0, 0, undefined,\n                       'This command does not take any arguments')\n        .strict()\n        .exitProcess(this.shouldExitProgram)\n        // Calling env() will be unnecessary after\n        // https://github.com/yargs/yargs/issues/486 is fixed\n        .env(envPrefix)\n        .options(commandOptions);\n    });\n    this.commands[name] = executor;\n    return this;\n  }\n\n  setGlobalOptions(options: Object): Program {\n    // This is a convenience for setting global options.\n    // An option is only global (i.e. available to all sub commands)\n    // with the `global` flag so this makes sure every option has it.\n    this.options = {...this.options, ...options};\n    Object.keys(options).forEach((key) => {\n      options[key].global = true;\n      if (options[key].demandOption === undefined) {\n        // By default, all options should be \"demanded\" otherwise\n        // yargs.strict() will think they are missing when declared.\n        options[key].demandOption = true;\n      }\n    });\n    this.yargs.options(options);\n    return this;\n  }\n\n  enableVerboseMode(\n    logStream: typeof defaultLogStream,\n    version: string\n  ): void {\n    if (this.verboseEnabled) {\n      return;\n    }\n\n    logStream.makeVerbose();\n    log.info('Version:', version);\n    this.verboseEnabled = true;\n  }\n\n  async execute(\n    {\n      checkForUpdates = defaultUpdateChecker,\n      systemProcess = process,\n      logStream = defaultLogStream,\n      getVersion = defaultVersionGetter,\n      applyConfigToArgv = defaultApplyConfigToArgv,\n      discoverConfigFiles = defaultConfigDiscovery,\n      loadJSConfigFile = defaultLoadJSConfigFile,\n      shouldExitProgram = true,\n      globalEnv = WEBEXT_BUILD_ENV,\n    }: ExecuteOptions = {}\n  ): Promise<void> {\n    this.shouldExitProgram = shouldExitProgram;\n    this.yargs.exitProcess(this.shouldExitProgram);\n\n    const argv = this.yargs.argv;\n\n    // Replacement for the \"requiresArg: true\" parameter until the following bug\n    // is fixed: https://github.com/yargs/yargs/issues/1098\n    if (argv.ignoreFiles && !argv.ignoreFiles.length) {\n      throw new UsageError('Not enough arguments following: ignore-files');\n    }\n\n    const cmd = argv._[0];\n\n    const version = getVersion(this.absolutePackageDir);\n    const runCommand = this.commands[cmd];\n\n    if (argv.verbose) {\n      this.enableVerboseMode(logStream, version);\n    }\n\n    let adjustedArgv = {...argv};\n\n    try {\n      if (cmd === undefined) {\n        throw new UsageError('No sub-command was specified in the args');\n      }\n      if (!runCommand) {\n        throw new UsageError(`Unknown command: ${cmd}`);\n      }\n      if (globalEnv === 'production') {\n        checkForUpdates({version});\n      }\n\n      const configFiles = [];\n\n      // Because of an issue with yargs special handling for '--no-' option prefix (See #306)\n      // we need to look explicitly for the options  --config-discovery and --no-config-discovery\n      // (See #1307).\n      if (argv.configDiscovery && !argv.noConfigDiscovery) {\n        log.debug(\n          'Discovering config files. ' +\n          'Set --no-config-discovery to disable');\n        const discoveredConfigs = await discoverConfigFiles();\n        configFiles.push(...discoveredConfigs);\n      } else {\n        log.debug('Not discovering config files');\n      }\n\n      if (argv.config) {\n        configFiles.push(path.resolve(argv.config));\n      }\n\n      if (configFiles.length) {\n        const niceFileList = configFiles\n          .map((f) => f.replace(process.cwd(), '.'))\n          .map((f) => f.replace(os.homedir(), '~'))\n          .join(', ');\n        log.info(\n          'Applying config file' +\n          `${configFiles.length !== 1 ? 's' : ''}: ` +\n          `${niceFileList}`);\n      }\n\n      configFiles.forEach((configFileName) => {\n        const configObject = loadJSConfigFile(configFileName);\n        adjustedArgv = applyConfigToArgv({\n          argv: adjustedArgv,\n          argvFromCLI: argv,\n          configFileName,\n          configObject,\n          options: this.options,\n        });\n      });\n\n      if (adjustedArgv.verbose) {\n        // Ensure that the verbose is enabled when specified in a config file.\n        this.enableVerboseMode(logStream, version);\n      }\n\n      await runCommand(adjustedArgv, {shouldExitProgram});\n\n    } catch (error) {\n      if (!(error instanceof UsageError) || adjustedArgv.verbose) {\n        log.error(`\\n${error.stack}\\n`);\n      } else {\n        log.error(`\\n${error}\\n`);\n      }\n      if (error.code) {\n        log.error(`Error code: ${error.code}\\n`);\n      }\n\n      log.debug(`Command executed: ${cmd}`);\n\n      if (this.shouldExitProgram) {\n        systemProcess.exit(1);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\n// A global variable generated by DefinePlugin, generated in webpack.config.js\ndeclare var WEBEXT_BUILD_ENV: string;\n\n//A defintion of type of argument for defaultVersionGetter\ntype VersionGetterOptions = {\n  globalEnv?: string,\n};\n\nexport function defaultVersionGetter(\n  absolutePackageDir: string,\n  {globalEnv = WEBEXT_BUILD_ENV}: VersionGetterOptions = {}\n): string {\n  if (globalEnv === 'production') {\n    log.debug('Getting the version from package.json');\n    const packageData: any = readFileSync(\n      path.join(absolutePackageDir, 'package.json'));\n    return JSON.parse(packageData).version;\n  } else {\n    log.debug('Getting version from the git revision');\n    return `${git.branch(absolutePackageDir)}-${git.long(absolutePackageDir)}`;\n  }\n}\n\n// TODO: add pipes to Flow type after https://github.com/facebook/flow/issues/2405 is fixed\n\ntype MainParams = {\n  getVersion?: VersionGetterFn,\n  commands?: Object,\n  argv: Array<any>,\n  runOptions?: Object,\n}\n\nexport function main(\n  absolutePackageDir: string,\n  {\n    getVersion = defaultVersionGetter, commands = defaultCommands, argv,\n    runOptions = {},\n  }: MainParams = {}\n): Promise<any> {\n  const program = new Program(argv, {absolutePackageDir});\n  const version = getVersion(absolutePackageDir);\n\n  // yargs uses magic camel case expansion to expose options on the\n  // final argv object. For example, the 'artifacts-dir' option is alternatively\n  // available as argv.artifactsDir.\n  program.yargs\n    .usage(`Usage: $0 [options] command\n\nOption values can also be set by declaring an environment variable prefixed\nwith $${envPrefix}_. For example: $${envPrefix}_SOURCE_DIR=/path is the same as\n--source-dir=/path.\n\nTo view specific help for any given command, add the command name.\nExample: $0 --help run.\n`)\n    .help('help')\n    .alias('h', 'help')\n    .env(envPrefix)\n    .version(version)\n    .demandCommand(1, 'You must specify a command')\n    .strict();\n\n  program.setGlobalOptions({\n    'source-dir': {\n      alias: 's',\n      describe: 'Web extension source directory.',\n      default: process.cwd(),\n      requiresArg: true,\n      type: 'string',\n      coerce: path.resolve,\n    },\n    'artifacts-dir': {\n      alias: 'a',\n      describe: 'Directory where artifacts will be saved.',\n      default: path.join(process.cwd(), 'web-ext-artifacts'),\n      normalize: true,\n      requiresArg: true,\n      type: 'string',\n    },\n    'verbose': {\n      alias: 'v',\n      describe: 'Show verbose output',\n      type: 'boolean',\n      demandOption: false,\n    },\n    'ignore-files': {\n      alias: 'i',\n      describe: 'A list of glob patterns to define which files should be ' +\n                'ignored. (Example: --ignore-files=path/to/first.js ' +\n                'path/to/second.js \"**/*.log\")',\n      demandOption: false,\n      // The following option prevents yargs>=11 from parsing multiple values,\n      // so the minimum value requirement is enforced in execute instead.\n      // Upstream bug: https://github.com/yargs/yargs/issues/1098\n      // requiresArg: true,\n      type: 'array',\n    },\n    'no-input': {\n      describe: 'Disable all features that require standard input',\n      type: 'boolean',\n      demandOption: false,\n    },\n    'config': {\n      alias: 'c',\n      describe: 'Path to a CommonJS config file to set ' +\n        'option defaults',\n      default: undefined,\n      demandOption: false,\n      requiresArg: true,\n      type: 'string',\n    },\n    'config-discovery': {\n      describe: 'Discover config files in home directory and ' +\n        'working directory. Disable with --no-config-discovery.',\n      demandOption: false,\n      default: true,\n      type: 'boolean',\n    },\n  });\n\n  program\n    .command(\n      'build',\n      'Create an extension package from source',\n      commands.build, {\n        'as-needed': {\n          describe: 'Watch for file changes and re-build as needed',\n          type: 'boolean',\n        },\n        'overwrite-dest': {\n          alias: 'o',\n          describe: 'Overwrite destination package if it exists.',\n          type: 'boolean',\n        },\n      })\n    .command(\n      'sign',\n      'Sign the extension so it can be installed in Firefox',\n      commands.sign, {\n        'api-key': {\n          describe: 'API key (JWT issuer) from addons.mozilla.org',\n          demandOption: true,\n          type: 'string',\n        },\n        'api-secret': {\n          describe: 'API secret (JWT secret) from addons.mozilla.org',\n          demandOption: true,\n          type: 'string',\n        },\n        'api-url-prefix': {\n          describe: 'Signing API URL prefix',\n          default: 'https://addons.mozilla.org/api/v3',\n          demandOption: true,\n          type: 'string',\n        },\n        'api-proxy': {\n          describe:\n            'Use a proxy to access the signing API. ' +\n            'Example: https://yourproxy:6000 ',\n          demandOption: false,\n          type: 'string',\n        },\n        'id': {\n          describe:\n            'A custom ID for the extension. This has no effect if the ' +\n            'extension already declares an explicit ID in its manifest.',\n          demandOption: false,\n          type: 'string',\n        },\n        'timeout': {\n          describe: 'Number of milliseconds to wait before giving up',\n          type: 'number',\n        },\n        'channel': {\n          describe: 'The channel for which to sign the addon. Either ' +\n          '\\'listed\\' or \\'unlisted\\'',\n          type: 'string',\n        },\n      })\n    .command('run', 'Run the extension', commands.run, {\n      'target': {\n        alias: 't',\n        describe: 'The extensions runners to enable. Specify this option ' +\n                  'multiple times to run against multiple targets.',\n        default: 'firefox-desktop',\n        demandOption: false,\n        type: 'array',\n        choices: ['firefox-desktop', 'firefox-android'],\n      },\n      'firefox': {\n        alias: ['f', 'firefox-binary'],\n        describe: 'Path or alias to a Firefox executable such as firefox-bin ' +\n                  'or firefox.exe. ' +\n                  'If not specified, the default Firefox will be used. ' +\n                  'You can specify the following aliases in lieu of a path: ' +\n                  'firefox, beta, nightly, firefoxdeveloperedition.',\n        demandOption: false,\n        type: 'string',\n      },\n      'firefox-profile': {\n        alias: 'p',\n        describe: 'Run Firefox using a copy of this profile. The profile ' +\n                  'can be specified as a directory or a name, such as one ' +\n                  'you would see in the Profile Manager. If not specified, ' +\n                  'a new temporary profile will be created.',\n        demandOption: false,\n        type: 'string',\n      },\n      'keep-profile-changes': {\n        describe: 'Run Firefox directly in custom profile. Any changes to ' +\n                  'the profile will be saved.',\n        demandOption: false,\n        type: 'boolean',\n      },\n      'no-reload': {\n        describe: 'Do not reload the extension when source files change',\n        demandOption: false,\n        type: 'boolean',\n      },\n      'pre-install': {\n        describe: 'Pre-install the extension into the profile before ' +\n                  'startup. This is only needed to support older versions ' +\n                  'of Firefox.',\n        demandOption: false,\n        type: 'boolean',\n      },\n      'pref': {\n        describe: 'Launch firefox with a custom preference ' +\n                  '(example: --pref=general.useragent.locale=fr-FR). ' +\n                  'You can repeat this option to set more than one ' +\n                  'preference.',\n        demandOption: false,\n        requiresArg: true,\n        type: 'array',\n        coerce: coerceCLICustomPreference,\n      },\n      'start-url': {\n        alias: ['u', 'url'],\n        describe: 'Launch firefox at specified page',\n        demandOption: false,\n        requiresArg: true,\n        type: 'array',\n      },\n      'browser-console': {\n        alias: ['bc'],\n        describe: 'Open the DevTools Browser Console.',\n        demandOption: false,\n        type: 'boolean',\n      },\n      'args': {\n        alias: ['arg'],\n        describe: 'Additional CLI options passed to the Browser binary',\n        demandOption: false,\n        type: 'array',\n      },\n      // Firefox for Android CLI options.\n      'adb-bin': {\n        describe: 'Specify a custom path to the adb binary',\n        demandOption: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'adb-host': {\n        describe: 'Connect to adb on the specified host',\n        demandOption: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'adb-port': {\n        describe: 'Connect to adb on the specified port',\n        demandOption: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'adb-device': {\n        alias: ['android-device'],\n        describe: 'Connect to the specified adb device name',\n        demandOption: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'firefox-apk': {\n        describe: (\n          'Run a specific Firefox for Android APK. ' +\n          'Example: org.mozilla.fennec_aurora'\n        ),\n        demandOption: false,\n        type: 'string',\n        requiresArg: true,\n      },\n    })\n    .command('lint', 'Validate the extension source', commands.lint, {\n      'output': {\n        alias: 'o',\n        describe: 'The type of output to generate',\n        type: 'string',\n        default: 'text',\n        choices: ['json', 'text'],\n      },\n      'metadata': {\n        describe: 'Output only metadata as JSON',\n        type: 'boolean',\n        default: false,\n      },\n      'warnings-as-errors': {\n        describe: 'Treat warnings as errors by exiting non-zero for warnings',\n        alias: 'w',\n        type: 'boolean',\n        default: false,\n      },\n      'pretty': {\n        describe: 'Prettify JSON output',\n        type: 'boolean',\n        default: false,\n      },\n      'self-hosted': {\n        describe:\n          'Your extension will be self-hosted. This disables messages ' +\n          'related to hosting on addons.mozilla.org.',\n        type: 'boolean',\n        default: false,\n      },\n      'boring': {\n        describe: 'Disables colorful shell output',\n        type: 'boolean',\n        default: false,\n      },\n    })\n    .command('docs', 'Open the web-ext documentation in a browser',\n             commands.docs, {});\n\n  return program.execute({getVersion, ...runOptions});\n}\n","module.exports = require(\"yargs\");","module.exports = require(\"watchpack\");","module.exports = require(\"debounce\");","/* @flow */\nimport {promisify} from 'util';\n\nimport zipDirModule from 'zip-dir';\n\nexport const zipDir = promisify(zipDirModule);\n","module.exports = require(\"zip-dir\");","module.exports = require(\"es6-error\");","module.exports = require(\"mkdirp\");","module.exports = require(\"multimatch\");","module.exports = require(\"addons-linter\");","module.exports = require(\"node-notifier\");","module.exports = require(\"fx-runner\");","module.exports = require(\"@cliqz-oss/node-firefox-connect\");","module.exports = require(\"net\");","/* @flow */\n\n/*\n * A small promisify helper to make it easier to customize a\n * function promisified (using the 'util' module available in\n * nodejs >= 8) to resolve to an array of results:\n *\n *    import {promisify} from 'util';\n *    import {multiArgsPromisedFn} from '../util/promisify';\n *\n *    aCallbackBasedFn[promisify.custom] = multiArgsPromisedFn(tmp.dir);\n *    ...\n */\nexport function multiArgsPromisedFn(fn: Function): Function {\n  return (...callerArgs: Array<any>): Promise<any> => {\n    return new Promise((resolve, reject) => {\n      fn(...callerArgs, (err, ...rest) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rest);\n        }\n      });\n    });\n  };\n}\n","/* @flow */\nimport defaultADB from 'adbkit';\n\nimport {\n  isErrorWithCode,\n  UsageError,\n  WebExtError,\n} from '../errors';\nimport {createLogger} from '../util/logger';\n\nconst log = createLogger(__filename);\n\nexport type ADBUtilsParams = {|\n  adb?: typeof defaultADB,\n  // ADB configs.\n  adbBin?: string,\n  adbHost?: string,\n  adbPort?: string,\n  adbDevice?: string,\n|};\n\nexport type DiscoveryParams = {|\n  maxDiscoveryTime: number,\n  retryInterval: number,\n|};\n\n// Helper function used to raise an UsageError when the adb binary has not been found.\nasync function wrapADBCall(asyncFn: (...any) => Promise<any>): Promise<any> {\n  try {\n    return await asyncFn();\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error) &&\n        error.message.includes('spawn adb')) {\n      throw new UsageError(\n        'No adb executable has been found. ' +\n          'You can Use --adb-bin, --adb-host/--adb-port ' +\n          'to configure it manually if needed.');\n    }\n\n    throw error;\n  }\n}\n\nexport default class ADBUtils {\n  params: ADBUtilsParams;\n  adb: typeof defaultADB;\n  adbClient: any; // TODO: better flow typing here.\n\n  // Map<deviceId -> artifactsDir>\n  artifactsDirMap: Map<string, string>;\n  // Toggled when the user wants to abort the RDP Unix Socket discovery loop\n  // while it is still executing.\n  userAbortDiscovery: boolean;\n\n  constructor(params: ADBUtilsParams) {\n    this.params = params;\n\n    const {\n      adb,\n      adbBin,\n      adbHost,\n      adbPort,\n    } = params;\n\n    this.adb = adb || defaultADB;\n\n    this.adbClient = this.adb.createClient({\n      bin: adbBin,\n      host: adbHost,\n      port: adbPort,\n    });\n\n    this.artifactsDirMap = new Map();\n\n    this.userAbortDiscovery = false;\n  }\n\n  runShellCommand(\n    deviceId: string, cmd: string | Array<string>\n  ): Promise<string> {\n    const {adb, adbClient} = this;\n\n    log.debug(`Run adb shell command on ${deviceId}: ${JSON.stringify(cmd)}`);\n\n    return wrapADBCall(async () => {\n      return await adbClient.shell(deviceId, cmd).then(adb.util.readAll);\n    }).then((res) => res.toString());\n  }\n\n  async discoverDevices(): Promise<Array<string>> {\n    const {adbClient} = this;\n\n    let devices = [];\n\n    log.debug('Listing android devices');\n    devices = await wrapADBCall(async () => adbClient.listDevices());\n\n    return devices.map((dev) => dev.id);\n  }\n\n  async discoverInstalledFirefoxAPKs(\n    deviceId: string,\n    firefoxApk?: string\n  ): Promise<Array<string>> {\n    log.debug(`Listing installed Firefox APKs on ${deviceId}`);\n\n    const pmList = await this.runShellCommand(deviceId, [\n      'pm', 'list', 'packages',\n    ]);\n\n    return pmList.split('\\n')\n      .map((line) => line.replace('package:', '').trim())\n      .filter((line) => {\n        // Look for an exact match if firefoxApk is defined.\n        if (firefoxApk) {\n          return line === firefoxApk;\n        }\n        // Match any package name that starts with the package name of a Firefox for Android browser.\n        return (\n          line.startsWith('org.mozilla.fennec') ||\n            line.startsWith('org.mozilla.firefox')\n        );\n      });\n  }\n\n  async getAndroidVersionNumber(deviceId: string): Promise<number> {\n    const androidVersion = (await this.runShellCommand(deviceId, [\n      'getprop', 'ro.build.version.sdk',\n    ])).trim();\n\n    const androidVersionNumber = parseInt(androidVersion);\n\n    // No need to check the granted runtime permissions on Android versions < Lollypop.\n    if (isNaN(androidVersionNumber)) {\n      throw new WebExtError(\n        'Unable to discovery android version on ' +\n        `${deviceId}: ${androidVersion}`\n      );\n    }\n\n    return androidVersionNumber;\n  }\n\n  // Raise an UsageError when the given APK does not have the required runtime permissions.\n  async ensureRequiredAPKRuntimePermissions(\n    deviceId: string, apk: string, permissions: Array<string>\n  ): Promise<void> {\n    const permissionsMap = {};\n\n    // Initialize every permission to false in the permissions map.\n    for (const perm of permissions) {\n      permissionsMap[perm] = false;\n    }\n\n    // Retrieve the permissions information for the given apk.\n    const pmDumpLogs = (await this.runShellCommand(deviceId, [\n      'pm', 'dump', apk,\n    ])).split('\\n');\n\n    // Set to true the required permissions that have been granted.\n    for (const line of pmDumpLogs) {\n      for (const perm of permissions) {\n        if (line.includes(`${perm}: granted=true`) ||\n            line.includes(`${perm}, granted=true`)) {\n          permissionsMap[perm] = true;\n        }\n      }\n    }\n\n    for (const perm of permissions) {\n      if (!permissionsMap[perm]) {\n        throw new UsageError(\n          `Required ${perm} has not be granted for ${apk}. ` +\n          'Please grant them using the Android Settings ' +\n          'or using the following adb command:\\n' +\n          `\\t adb shell pm grant ${apk} ${perm}\\n`\n        );\n      }\n    }\n  }\n\n  async amForceStopAPK(deviceId: string, apk: string): Promise<void> {\n    await this.runShellCommand(deviceId, [\n      'am', 'force-stop', apk,\n    ]);\n  }\n\n  async getOrCreateArtifactsDir(deviceId: string): Promise<string> {\n    let artifactsDir = this.artifactsDirMap.get(deviceId);\n\n    if (artifactsDir) {\n      return artifactsDir;\n    }\n\n    artifactsDir = `/sdcard/web-ext-artifacts-${Date.now()}`;\n\n    const testDirOut = (await this.runShellCommand(\n      deviceId, `test -d ${artifactsDir} ; echo $?`\n    )).trim();\n\n    if (testDirOut !== '1') {\n      throw new WebExtError(\n        `Cannot create artifacts directory ${artifactsDir} ` +\n        `because it exists on ${deviceId}.`\n      );\n    }\n\n    await this.runShellCommand(deviceId, ['mkdir', '-p', artifactsDir]);\n\n    this.artifactsDirMap.set(deviceId, artifactsDir);\n\n    return artifactsDir;\n  }\n\n  async clearArtifactsDir(deviceId: string): Promise<void> {\n    const artifactsDir = this.artifactsDirMap.get(deviceId);\n\n    if (!artifactsDir) {\n      // nothing to do here.\n      return;\n    }\n\n    this.artifactsDirMap.delete(deviceId);\n\n    log.debug(\n      `Removing ${artifactsDir} artifacts directory on ${deviceId} device`\n    );\n\n    await this.runShellCommand(deviceId, [\n      'rm', '-rf', artifactsDir,\n    ]);\n  }\n\n  async pushFile(\n    deviceId: string, localPath: string, devicePath: string\n  ): Promise<void> {\n    const {adbClient} = this;\n\n    log.debug(`Pushing ${localPath} to ${devicePath} on ${deviceId}`);\n\n    await wrapADBCall(async () => {\n      await adbClient.push(deviceId, localPath, devicePath)\n        .then(function(transfer) {\n          return new Promise((resolve) => {\n            transfer.on('end', resolve);\n          });\n        });\n    });\n  }\n\n  async startFirefoxAPK(\n    deviceId: string, apk: string, deviceProfileDir: string\n  ): Promise<void> {\n    const {adbClient} = this;\n\n    log.debug(\n      `Starting ${apk} with profile ${deviceProfileDir} on ${deviceId}`\n    );\n\n    await wrapADBCall(async () => {\n      await adbClient.startActivity(deviceId, {\n        wait: true,\n        action: 'android.activity.MAIN',\n        component: `${apk}/.App`,\n        extras: [\n          {\n            key: 'args',\n            value: `-profile ${deviceProfileDir}`,\n          },\n        ],\n      });\n    });\n  }\n\n  setUserAbortDiscovery(value: boolean) {\n    this.userAbortDiscovery = value;\n  }\n\n  async discoverRDPUnixSocket(\n    deviceId: string, apk: string,\n    {maxDiscoveryTime, retryInterval}: DiscoveryParams = {}\n  ): Promise<string> {\n    let rdpUnixSockets = [];\n\n    const discoveryStartedAt = Date.now();\n\n    while (rdpUnixSockets.length === 0) {\n      if (this.userAbortDiscovery) {\n        throw new UsageError(\n          'Exiting Firefox Remote Debugging socket discovery on user request'\n        );\n      }\n\n      if (Date.now() - discoveryStartedAt > maxDiscoveryTime) {\n        throw new WebExtError(\n          'Timeout while waiting for the Android Firefox Debugger Socket'\n        );\n      }\n\n      rdpUnixSockets = (await this.runShellCommand(deviceId, [\n        'cat', '/proc/net/unix',\n      ])).split('\\n').filter((line) => {\n        // The RDP unix socket is expected to be a path in the form:\n        //   /data/data/org.mozilla.fennec_rpl/firefox-debugger-socket\n        return line.trim().endsWith(`${apk}/firefox-debugger-socket`);\n      });\n\n      if (rdpUnixSockets.length === 0) {\n        await new Promise((resolve) => setTimeout(resolve, retryInterval));\n      }\n    }\n\n    // Convert into an array of unix socket filenames.\n    rdpUnixSockets = rdpUnixSockets.map((line) => {\n      return line.trim().split(/\\s/).pop();\n    });\n\n    if (rdpUnixSockets.length > 1) {\n      throw new WebExtError(\n        'Unexpected multiple RDP sockets: ' +\n        `${JSON.stringify(rdpUnixSockets)}`\n      );\n    }\n\n    return rdpUnixSockets[0];\n  }\n\n  async setupForward(deviceId: string, remote: string, local: string) {\n    const {adbClient} = this;\n\n    // TODO(rpl): we should use adb.listForwards and reuse the existing one if any (especially\n    // because adbkit doesn't seem to support `adb forward --remote` yet).\n    log.debug(`Configuring ADB forward for ${deviceId}: ${remote} -> ${local}`);\n\n    await wrapADBCall(async () => {\n      await adbClient.forward(deviceId, local, remote);\n    });\n  }\n}\n","module.exports = require(\"adbkit\");","module.exports = require(\"sign-addon\");","module.exports = require(\"opn\");","/* @flow */\nimport defaultUpdateNotifier from 'update-notifier';\n\ntype CheckForUpdatesParams = {|\n  version: string,\n  updateNotifier?: typeof defaultUpdateNotifier,\n|};\n\nexport function checkForUpdates(\n  {\n    version,\n    updateNotifier = defaultUpdateNotifier,\n  }: CheckForUpdatesParams\n) {\n  const pkg = {name: 'web-ext', version};\n\n  updateNotifier({\n    pkg,\n    updateCheckInterval: 1000 * 60 * 60 * 24 * 3, // 3 days,\n  }).notify();\n}\n","module.exports = require(\"update-notifier\");","module.exports = require(\"require-uncached\");","module.exports = require(\"decamelize\");","/* @flow */\nimport {fs} from 'mz';\n\nimport {isErrorWithCode} from '../errors';\n\ntype FileExistsOptions = {|\n  fileIsReadable: (filePath: string) => Promise<boolean>,\n|};\n\n/*\n * Resolves true if the path is a readable file.\n *\n * Usage:\n *\n * const exists = await fileExists(filePath);\n * if (exists) {\n *   // ...\n * }\n *\n * */\nexport default async function fileExists(\n  path: string,\n  {\n    fileIsReadable = (f) => fs.access(f, fs.constants.R_OK),\n  }: FileExistsOptions = {}\n): Promise<boolean> {\n  try {\n    await fileIsReadable(path);\n    const stat = await fs.stat(path);\n    return stat.isFile();\n  } catch (error) {\n    if (isErrorWithCode(['EACCES', 'ENOENT'], error)) {\n      return false;\n    }\n    throw error;\n  }\n}\n","/* @flow */\nimport {main} from './program';\nimport cmd from './cmd';\nimport * as logger from './util/logger';\n\n// This only exposes util/logger so far.\n// Do we need anything else?\nconst util = {logger};\n\nexport default {main, cmd, util};\n","/* @flow */\nimport {createInstance as defaultLinterCreator} from 'addons-linter';\n\nimport {createLogger} from '../util/logger';\nimport {\n  createFileFilter as defaultFileFilterCreator,\n} from '../util/file-filter';\n// import flow types\nimport type {FileFilterCreatorFn} from '../util/file-filter';\n\nconst log = createLogger(__filename);\n\n\n// Define the needed 'addons-linter' module flow types.\n\nexport type LinterOutputType = 'text' | 'json';\n\nexport type LinterCreatorParams = {|\n  config: {|\n    logLevel: 'debug' | 'fatal',\n    stack: boolean,\n    pretty?: boolean,\n    warningsAsErrors?: boolean,\n    metadata?: boolean,\n    output?: LinterOutputType,\n    boring?: boolean,\n    selfHosted?: boolean,\n    shouldScanFile: (fileName: string) => boolean,\n    _: Array<string>,\n  |},\n  runAsBinary: boolean,\n|};\n\nexport type Linter = {|\n  run: () => Promise<void>,\n|};\n\nexport type LinterCreatorFn = (params: LinterCreatorParams) => Linter;\n\n\n// Lint command types and implementation.\n\nexport type LintCmdParams = {|\n  artifactsDir?: string,\n  boring?: boolean,\n  ignoreFiles?: Array<string>,\n  metadata?: boolean,\n  output?: LinterOutputType,\n  pretty?: boolean,\n  selfHosted?: boolean,\n  sourceDir: string,\n  verbose?: boolean,\n  warningsAsErrors?: boolean,\n|};\n\nexport type LintCmdOptions = {|\n  createLinter?: LinterCreatorFn,\n  createFileFilter?: FileFilterCreatorFn,\n  shouldExitProgram?: boolean,\n|};\n\nexport default function lint(\n  {\n    artifactsDir,\n    boring,\n    ignoreFiles,\n    metadata,\n    output,\n    pretty,\n    sourceDir,\n    selfHosted,\n    verbose,\n    warningsAsErrors,\n  }: LintCmdParams,\n  {\n    createLinter = defaultLinterCreator,\n    createFileFilter = defaultFileFilterCreator,\n    shouldExitProgram = true,\n  }: LintCmdOptions = {}\n): Promise<void> {\n  const fileFilter = createFileFilter({sourceDir, ignoreFiles, artifactsDir});\n\n  log.debug(`Running addons-linter on ${sourceDir}`);\n  const linter = createLinter({\n    config: {\n      logLevel: verbose ? 'debug' : 'fatal',\n      stack: Boolean(verbose),\n      pretty,\n      warningsAsErrors,\n      metadata,\n      output,\n      boring,\n      selfHosted,\n      shouldScanFile: (fileName) => fileFilter.wantFile(fileName),\n      // This mimics the first command line argument from yargs,\n      // which should be the directory to the extension.\n      _: [sourceDir],\n    },\n    runAsBinary: shouldExitProgram,\n  });\n  return linter.run();\n}\n","/* @flow */\nimport defaultBuildExtension from './build';\nimport {\n  showDesktopNotification as defaultDesktopNotifications,\n} from '../util/desktop-notifier';\nimport * as defaultFirefoxApp from '../firefox';\nimport {\n  connectWithMaxRetries as defaultFirefoxClient,\n} from '../firefox/remote';\nimport {createLogger} from '../util/logger';\nimport defaultGetValidatedManifest from '../util/manifest';\nimport {\n  createExtensionRunner,\n  defaultReloadStrategy,\n  MultiExtensionRunner as DefaultMultiExtensionRunner,\n} from '../extension-runners';\n// Import objects that are only used as Flow types.\nimport type {FirefoxPreferences} from '../firefox/preferences';\n\nconst log = createLogger(__filename);\n\n\n// Run command types and implementation.\n\nexport type CmdRunParams = {|\n  artifactsDir: string,\n  browserConsole: boolean,\n  pref?: FirefoxPreferences,\n  firefox: string,\n  firefoxProfile?: string,\n  ignoreFiles?: Array<string>,\n  keepProfileChanges: boolean,\n  noInput?: boolean,\n  noReload: boolean,\n  preInstall: boolean,\n  sourceDir: string,\n  startUrl?: Array<string>,\n  target?: Array<string>,\n  args?: Array<string>,\n\n  // Android CLI options.\n  adbBin?: string,\n  adbHost?: string,\n  adbPort?: string,\n  adbDevice?: string,\n  firefoxApk?: string,\n|};\n\nexport type CmdRunOptions = {|\n  buildExtension: typeof defaultBuildExtension,\n  desktopNotifications: typeof defaultDesktopNotifications,\n  firefoxApp: typeof defaultFirefoxApp,\n  firefoxClient: typeof defaultFirefoxClient,\n  reloadStrategy: typeof defaultReloadStrategy,\n  shouldExitProgram?: boolean,\n  MultiExtensionRunner?: typeof DefaultMultiExtensionRunner,\n  getValidatedManifest?: typeof defaultGetValidatedManifest,\n|};\n\nexport default async function run(\n  {\n    artifactsDir,\n    browserConsole = false,\n    pref,\n    firefox,\n    firefoxProfile,\n    keepProfileChanges = false,\n    ignoreFiles,\n    noInput = false,\n    noReload = false,\n    preInstall = false,\n    sourceDir,\n    startUrl,\n    target,\n    // Android CLI options.\n    adbBin,\n    adbHost,\n    adbPort,\n    adbDevice,\n    firefoxApk,\n    args,\n  }: CmdRunParams,\n  {\n    buildExtension = defaultBuildExtension,\n    desktopNotifications = defaultDesktopNotifications,\n    firefoxApp = defaultFirefoxApp,\n    firefoxClient = defaultFirefoxClient,\n    reloadStrategy = defaultReloadStrategy,\n    MultiExtensionRunner = DefaultMultiExtensionRunner,\n    getValidatedManifest = defaultGetValidatedManifest,\n  }: CmdRunOptions = {}): Promise<DefaultMultiExtensionRunner> {\n\n  log.info(`Running web extension from ${sourceDir}`);\n  if (preInstall) {\n    log.info('Disabled auto-reloading because it\\'s not possible with ' +\n             '--pre-install');\n    noReload = true;\n  }\n\n  // Create an alias for --pref since it has been transformed into an\n  // object containing one or more preferences.\n  const customPrefs = pref;\n  const manifestData = await getValidatedManifest(sourceDir);\n\n  const runners = [];\n\n  const commonRunnerParams = {\n    // Common options.\n    extensions: [{sourceDir, manifestData}],\n    keepProfileChanges,\n    startUrl,\n    args,\n    desktopNotifications,\n  };\n\n  if (!target || target.length === 0 || target.includes('firefox-desktop')) {\n    const firefoxDesktopRunnerParams = {\n      ...commonRunnerParams,\n\n      // Firefox specific CLI options.\n      firefoxBinary: firefox,\n      profilePath: firefoxProfile,\n      customPrefs,\n      browserConsole,\n      preInstall,\n\n      // Firefox runner injected dependencies.\n      firefoxApp,\n      firefoxClient,\n    };\n\n    const firefoxDesktopRunner = await createExtensionRunner({\n      target: 'firefox-desktop',\n      params: firefoxDesktopRunnerParams,\n    });\n    runners.push(firefoxDesktopRunner);\n  }\n\n  if (target && target.includes('firefox-android')) {\n    const firefoxAndroidRunnerParams = {\n      ...commonRunnerParams,\n\n      // Firefox specific CLI options.\n      profilePath: firefoxProfile,\n      customPrefs,\n      browserConsole,\n      preInstall,\n      firefoxApk,\n      adbDevice,\n      adbHost,\n      adbPort,\n      adbBin,\n\n      // Injected dependencies.\n      firefoxApp,\n      firefoxClient,\n      desktopNotifications: defaultDesktopNotifications,\n      buildSourceDir: (extensionSourceDir: string, tmpArtifactsDir: string) => {\n        return buildExtension({\n          sourceDir: extensionSourceDir,\n          ignoreFiles,\n          asNeeded: false,\n          // Use a separate temporary directory for building the extension zip file\n          // that we are going to upload on the android device.\n          artifactsDir: tmpArtifactsDir,\n        }, {\n          // Suppress the message usually logged by web-ext build.\n          showReadyMessage: false,\n        });\n      },\n    };\n\n    const firefoxAndroidRunner = await createExtensionRunner({\n      target: 'firefox-android',\n      params: firefoxAndroidRunnerParams,\n    });\n    runners.push(firefoxAndroidRunner);\n  }\n\n  const extensionRunner = new MultiExtensionRunner({\n    desktopNotifications,\n    runners,\n  });\n\n  await extensionRunner.run();\n\n  if (noReload) {\n    log.info('Automatic extension reloading has been disabled');\n  } else {\n    log.info('The extension will reload if any source file changes');\n\n    reloadStrategy({\n      extensionRunner,\n      sourceDir,\n      artifactsDir,\n      ignoreFiles,\n      noInput,\n    });\n  }\n\n  return extensionRunner;\n}\n","/* @flow */\n\n/**\n * This module provide an ExtensionRunner subclass that manage an extension executed\n * in a Firefox for Desktop instance.\n */\n\n// Import flow types from npm dependencies.\nimport type FirefoxProfile from 'firefox-profile';\n\nimport {\n  MultiExtensionsReloadError,\n  RemoteTempInstallNotSupported,\n  WebExtError,\n} from '../errors';\nimport * as defaultFirefoxApp from '../firefox';\nimport {\n  connectWithMaxRetries as defaultFirefoxConnector,\n} from '../firefox/remote';\nimport {createLogger} from '../util/logger';\n// Import flow types from project files.\nimport type {\n  FirefoxRDPResponseAddon,\n  RemoteFirefox,\n} from '../firefox/remote';\nimport type {\n  ExtensionRunnerParams,\n  ExtensionRunnerReloadResult,\n} from './base';\nimport type {FirefoxPreferences} from '../firefox/preferences';\nimport type {FirefoxInfo} from '../firefox/index'; // eslint-disable-line import/named\n\ntype FirefoxDesktopSpecificRunnerParams = {|\n  customPrefs?: FirefoxPreferences,\n  browserConsole: boolean,\n  firefoxBinary: string,\n  preInstall: boolean,\n\n  // Firefox desktop injected dependencies.\n  firefoxApp: typeof defaultFirefoxApp,\n  firefoxClient: typeof defaultFirefoxConnector,\n|};\n\nexport type FirefoxDesktopExtensionRunnerParams = {|\n  ...ExtensionRunnerParams,\n  // Firefox desktop CLI params.\n  ...FirefoxDesktopSpecificRunnerParams,\n|};\n\nconst log = createLogger(__filename);\n\n/**\n * Implements an IExtensionRunner which manages a Firefox Desktop instance.\n */\nexport class FirefoxDesktopExtensionRunner {\n  cleanupCallbacks: Set<Function>;\n  params: FirefoxDesktopExtensionRunnerParams;\n  profile: FirefoxProfile;\n  // Map extensions sourceDir to their related addon ids.\n  reloadableExtensions: Map<string, string>;\n  remoteFirefox: RemoteFirefox;\n  runningInfo: FirefoxInfo;\n\n  constructor(params: FirefoxDesktopExtensionRunnerParams) {\n    this.params = params;\n\n    this.reloadableExtensions = new Map();\n    this.cleanupCallbacks = new Set();\n  }\n\n  // Method exported from the IExtensionRunner interface.\n\n  /**\n   * Returns the runner name.\n   */\n  getName() {\n    return 'Firefox Desktop';\n  }\n\n  /**\n   * Setup the Firefox Profile and run a Firefox Desktop instance.\n   */\n  async run(): Promise<void> {\n    // Get a firefox profile with the custom Prefs set (a new or a cloned one).\n    // Pre-install extensions as proxy if needed (and disable auto-reload if you do)\n    await this.setupProfileDir();\n\n    // (if reload is enabled):\n    // - Connect to the firefox instance on RDP\n    // - Install any extension if needed (if not installed as proxy)\n    // - Keep track of the extension id assigned in a map with the sourceDir as a key\n    await this.startFirefoxInstance();\n  }\n\n  /**\n   * Reloads all the extensions, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadAllExtensions(): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const reloadErrors = new Map();\n    for (const {sourceDir} of this.params.extensions) {\n      const [res] = await this.reloadExtensionBySourceDir(sourceDir);\n      if (res.reloadError instanceof Error) {\n        reloadErrors.set(sourceDir, res.reloadError);\n      }\n    }\n\n    if (reloadErrors.size > 0) {\n      return [{\n        runnerName,\n        reloadError: new MultiExtensionsReloadError(reloadErrors),\n      }];\n    }\n\n    return [{runnerName}];\n  }\n\n  /**\n   * Reloads a single extension, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadExtensionBySourceDir(\n    extensionSourceDir: string\n  ): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const addonId = this.reloadableExtensions.get(extensionSourceDir);\n\n    if (!addonId) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: new WebExtError(\n          'Extension not reloadable: ' +\n          `no addonId has been mapped to \"${extensionSourceDir}\"`\n        ),\n        runnerName,\n      }];\n    }\n\n    try {\n      await this.remoteFirefox.reloadAddon(addonId);\n    } catch (error) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: error,\n        runnerName,\n      }];\n    }\n\n    return [{runnerName, sourceDir: extensionSourceDir}];\n  }\n\n  /**\n   * Register a callback to be called when the runner has been exited\n   * (e.g. the Firefox instance exits or the user has requested web-ext\n   * to exit).\n   */\n  registerCleanup(fn: Function): void {\n    this.cleanupCallbacks.add(fn);\n  }\n\n  /**\n   * Exits the runner, by closing the managed Firefox instance.\n   */\n  async exit(): Promise<void> {\n    if (!this.runningInfo || !this.runningInfo.firefox) {\n      throw new WebExtError('No firefox instance is currently running');\n    }\n\n    this.runningInfo.firefox.kill();\n  }\n\n  // Private helper methods.\n\n  async setupProfileDir() {\n    const {\n      customPrefs,\n      extensions,\n      keepProfileChanges,\n      preInstall,\n      profilePath,\n      firefoxApp,\n    } = this.params;\n\n    if (profilePath) {\n      if (keepProfileChanges) {\n        log.debug(`Using Firefox profile from ${profilePath}`);\n        this.profile = await firefoxApp.useProfile(profilePath, {customPrefs});\n      } else {\n        log.debug(`Copying Firefox profile from ${profilePath}`);\n        this.profile = await firefoxApp.copyProfile(profilePath, {customPrefs});\n      }\n    } else {\n      log.debug('Creating new Firefox profile');\n      this.profile = await firefoxApp.createProfile({customPrefs});\n    }\n\n    // preInstall the extensions if needed.\n    if (preInstall) {\n      for (const extension of extensions) {\n        await firefoxApp.installExtension({\n          asProxy: true,\n          extensionPath: extension.sourceDir,\n          manifestData: extension.manifestData,\n          profile: this.profile,\n        });\n      }\n    }\n  }\n\n  async startFirefoxInstance() {\n    const {\n      browserConsole,\n      extensions,\n      firefoxBinary,\n      preInstall,\n      startUrl,\n      firefoxApp,\n      firefoxClient,\n      args,\n    } = this.params;\n\n    const binaryArgs = [];\n\n    if (browserConsole) {\n      binaryArgs.push('-jsconsole');\n    }\n    if (startUrl) {\n      const urls = Array.isArray(startUrl) ? startUrl : [startUrl];\n      for (const url of urls) {\n        binaryArgs.push('--url', url);\n      }\n    }\n\n    if (args) {\n      binaryArgs.push(...args);\n    }\n\n    this.runningInfo = await firefoxApp.run(this.profile, {\n      firefoxBinary, binaryArgs,\n    });\n\n    this.runningInfo.firefox.on('close', () => {\n      for (const cleanupCb of this.cleanupCallbacks) {\n        try {\n          cleanupCb();\n        } catch (error) {\n          log.error(`Exception on executing cleanup callback: ${error}`);\n        }\n      }\n    });\n\n    if (!preInstall) {\n      const remoteFirefox = this.remoteFirefox = await firefoxClient({\n        port: this.runningInfo.debuggerPort,\n      });\n\n      // Install all the temporary addons.\n      for (const extension of extensions) {\n        try {\n          const addonId = await (\n            remoteFirefox.installTemporaryAddon(extension.sourceDir)\n              .then((installResult: FirefoxRDPResponseAddon) => {\n                return installResult.addon.id;\n              })\n          );\n\n          if (!addonId) {\n            throw new WebExtError(\n              'Unexpected missing addonId in the installAsTemporaryAddon result'\n            );\n          }\n\n          this.reloadableExtensions.set(extension.sourceDir, addonId);\n        } catch (error) {\n          if (error instanceof RemoteTempInstallNotSupported) {\n            log.debug(`Caught: ${error}`);\n            throw new WebExtError(\n              'Temporary add-on installation is not supported in this version' +\n              ' of Firefox (you need Firefox 49 or higher). For older Firefox' +\n              ' versions, use --pre-install'\n            );\n          } else {\n            throw error;\n          }\n        }\n      }\n    }\n  }\n}\n","/* @flow */\n\n/**\n * This module provide an ExtensionRunner subclass that manage an extension executed\n * in a Firefox for Android instance.\n */\n\nimport net from 'net';\nimport path from 'path';\nimport readline from 'readline';\n\nimport {withTempDir} from '../util/temp-dir';\nimport DefaultADBUtils from '../util/adb';\nimport {\n  showDesktopNotification as defaultDesktopNotifications,\n} from '../util/desktop-notifier';\nimport {\n  MultiExtensionsReloadError,\n  UsageError,\n  WebExtError,\n} from '../errors';\nimport * as defaultFirefoxApp from '../firefox';\nimport {\n  connectWithMaxRetries as defaultFirefoxConnector,\n} from '../firefox/remote';\nimport {createLogger} from '../util/logger';\nimport {isTTY, setRawMode} from '../util/stdin';\nimport type {\n  ExtensionRunnerParams,\n  ExtensionRunnerReloadResult,\n} from './base';\nimport type {\n  FirefoxPreferences,\n} from '../firefox/preferences';\nimport type {\n  FirefoxRDPResponseAddon,\n  RemoteFirefox,\n} from '../firefox/remote';\nimport type {\n  ExtensionBuildResult,\n} from '../cmd/build';\n\nconst log = createLogger(__filename);\n\nconst ignoredParams = {\n  profilePath: '--profile-path',\n  keepProfileChanges: '--keep-profile-changes',\n  browserConsole: '--browser-console',\n  preInstall: '--pre-install',\n  startUrl: '--start-url',\n  args: '--args',\n};\n\nconst getIgnoredParamsWarningsMessage = (optionName) => {\n  return `The Firefox for Android target does not support ${optionName}`;\n};\n\nexport type FirefoxAndroidExtensionRunnerParams = {|\n  ...ExtensionRunnerParams,\n\n  // Firefox specific.\n  customPrefs?: FirefoxPreferences,\n\n  // Not supported (currently ignored with logged warning).\n  preInstall?: boolean,\n  browserConsole?: boolean,\n\n  // Firefox android injected dependencies.\n  adbBin?: string,\n  adbHost?: string,\n  adbPort?: string,\n  adbDevice?: string,\n  firefoxApk?: string,\n  firefoxAndroidTimeout?: number,\n\n  // Injected Dependencies.\n  firefoxApp: typeof defaultFirefoxApp,\n  firefoxClient: typeof defaultFirefoxConnector,\n  ADBUtils?: typeof DefaultADBUtils,\n  buildSourceDir: (string, string) => Promise<ExtensionBuildResult>,\n  desktopNotifications: typeof defaultDesktopNotifications,\n  stdin?: stream$Readable,\n|};\n\n/**\n * Implements an IExtensionRunner which manages a Firefox for Android instance.\n */\nexport class FirefoxAndroidExtensionRunner {\n  // Wait 3s before the next unix socket discovery loop.\n  static unixSocketDiscoveryRetryInterval = 3 * 1000;\n  // Wait for at most 3 minutes before giving up.\n  static unixSocketDiscoveryMaxTime = 3 * 60 * 1000;\n\n  params: FirefoxAndroidExtensionRunnerParams;\n  adbUtils: DefaultADBUtils;\n  exiting: boolean;\n  selectedAdbDevice: string;\n  selectedFirefoxApk: string;\n  selectedArtifactsDir: string;\n  selectedRDPSocketFile: string;\n  selectedTCPPort: number;\n  cleanupCallbacks: Set<Function>;\n  adbExtensionsPathBySourceDir: Map<string, string>;\n  reloadableExtensions: Map<string, string>;\n  remoteFirefox: RemoteFirefox;\n\n  constructor(params: FirefoxAndroidExtensionRunnerParams) {\n    this.params = params;\n    this.cleanupCallbacks = new Set();\n    this.adbExtensionsPathBySourceDir = new Map();\n    this.reloadableExtensions = new Map();\n\n    // Print warning for not currently supported options (e.g. preInstall,\n    // cloned profiles, browser console).\n    this.printIgnoredParamsWarnings();\n  }\n\n  async run(): Promise<void> {\n    const {\n      adbBin,\n      adbHost,\n      adbPort,\n      ADBUtils = DefaultADBUtils,\n    } = this.params;\n\n    this.adbUtils = new ADBUtils({\n      adbBin, adbHost, adbPort,\n    });\n\n    await this.adbDevicesDiscoveryAndSelect();\n    await this.apkPackagesDiscoveryAndSelect();\n    await this.adbCheckRuntimePermissions();\n    await this.adbForceStopSelectedPackage();\n\n    // Create profile prefs (with enabled remote RDP server), prepare the\n    // artifacts and temporary directory on the selected device, and\n    // push the profile preferences to the remote profile dir.\n    await this.adbPrepareProfileDir();\n\n    // NOTE: running Firefox for Android on the Android Emulator can be\n    // pretty slow, we can run the following 3 steps in parallel to speed up\n    // it a bit.\n    await Promise.all([\n      // Start Firefox for Android instance on the created profile.\n      this.adbStartSelectedPackage(),\n\n      // Build and push to devices all the extension xpis\n      // and keep track of the xpi built and uploaded by extension sourceDir.\n      this.buildAndPushExtensions(),\n\n      // Wait for RDP unix socket file created and\n      // Create an ADB forward connection on a free tcp port\n      this.adbDiscoveryAndForwardRDPUnixSocket(),\n    ]);\n\n    // Connect to RDP socket on the local tcp server, install all the pushed extension\n    // and keep track of the built and installed extension by extension sourceDir.\n    await this.rdpInstallExtensions();\n  }\n\n  // Method exported from the IExtensionRunner interface.\n\n  /**\n   * Returns the runner name.\n   */\n  getName() {\n    return 'Firefox Android';\n  }\n\n  /**\n   * Reloads all the extensions, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadAllExtensions(): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const reloadErrors = new Map();\n\n    for (const {sourceDir} of this.params.extensions) {\n      const [res] = await this.reloadExtensionBySourceDir(sourceDir);\n      if (res.reloadError instanceof Error) {\n        reloadErrors.set(sourceDir, res.reloadError);\n      }\n    }\n\n    if (reloadErrors.size > 0) {\n      return [{\n        runnerName,\n        reloadError: new MultiExtensionsReloadError(reloadErrors),\n      }];\n    }\n\n    return [{runnerName}];\n  }\n\n  /**\n   * Reloads a single extension, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadExtensionBySourceDir(\n    extensionSourceDir: string\n  ): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const addonId = this.reloadableExtensions.get(extensionSourceDir);\n\n    if (!addonId) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: new WebExtError(\n          'Extension not reloadable: ' +\n            `no addonId has been mapped to \"${extensionSourceDir}\"`\n        ),\n        runnerName,\n      }];\n    }\n\n    try {\n      await this.buildAndPushExtension(extensionSourceDir);\n      await this.remoteFirefox.reloadAddon(addonId);\n    } catch (error) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: error,\n        runnerName,\n      }];\n    }\n\n    return [{runnerName, sourceDir: extensionSourceDir}];\n  }\n\n  /**\n   * Register a callback to be called when the runner has been exited\n   * (e.g. the Firefox instance exits or the user has requested web-ext\n   * to exit).\n   */\n  registerCleanup(fn: Function): void {\n    this.cleanupCallbacks.add(fn);\n  }\n\n  /**\n   * Exits the runner, by closing the managed Firefox instance.\n   */\n  async exit(): Promise<void> {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedArtifactsDir,\n    } = this;\n\n    this.exiting = true;\n\n    // If a Firefox for Android instance has been started,\n    // we should ensure that it has been stopped when we exit.\n    await this.adbForceStopSelectedPackage();\n\n    if (selectedArtifactsDir) {\n      log.debug('Cleaning up artifacts directory on the Android device...');\n      await adbUtils.clearArtifactsDir(selectedAdbDevice);\n    }\n\n    // Call all the registered cleanup callbacks.\n    for (const fn of this.cleanupCallbacks) {\n      try {\n        fn();\n      } catch (error) {\n        log.error(error);\n      }\n    }\n  }\n\n  // Private helper methods.\n\n  getDeviceProfileDir(): string {\n    return `${this.selectedArtifactsDir}/profile`;\n  }\n\n  printIgnoredParamsWarnings() {\n    Object.keys(ignoredParams).forEach((ignoredParam) => {\n      if (this.params[ignoredParam]) {\n        log.warn(\n          getIgnoredParamsWarningsMessage(ignoredParams[ignoredParam])\n        );\n      }\n    });\n  }\n\n  async adbDevicesDiscoveryAndSelect() {\n    const {adbUtils} = this;\n    const {adbDevice} = this.params;\n    let devices = [];\n\n    log.debug('Listing android devices');\n    devices = await adbUtils.discoverDevices();\n\n    if (devices.length === 0) {\n      throw new UsageError(\n        'No Android device found through ADB. ' +\n        'Make sure the device is connected and USB debugging is enabled.'\n      );\n    }\n\n    if (!adbDevice) {\n      const devicesMsg = devices.map((dev) => ` - ${dev}`).join('\\n');\n      log.info(`\\nAndroid devices found:\\n${devicesMsg}`);\n      throw new UsageError(\n        'Select an android device using --android-device=<name>');\n    }\n\n    const foundDevices = devices.filter((device) => {\n      return device === adbDevice;\n    });\n\n    if (foundDevices.length === 0) {\n      const devicesMsg = JSON.stringify(devices);\n      throw new UsageError(\n        `Android device ${adbDevice} was not found in list: ${devicesMsg}`);\n    }\n\n    this.selectedAdbDevice = foundDevices[0];\n    log.info(`Selected ADB device: ${this.selectedAdbDevice}`);\n  }\n\n  async apkPackagesDiscoveryAndSelect() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      params: {\n        firefoxApk,\n      },\n    } = this;\n    // Discovery and select a Firefox for Android version.\n    const packages = await adbUtils.discoverInstalledFirefoxAPKs(\n      selectedAdbDevice,\n      firefoxApk\n    );\n\n    if (packages.length === 0) {\n      throw new UsageError(\n        'No Firefox packages were found on the selected Android device');\n    }\n\n    const pkgsListMsg = (pkgs) => {\n      return pkgs.map((pkg) => ` - ${ pkg}`).join('\\n');\n    };\n\n    if (!firefoxApk) {\n      log.info(`\\nPackages found:\\n${pkgsListMsg(packages)}`);\n\n      if (packages.length > 1) {\n        throw new UsageError('Select one of the packages using --firefox-apk');\n      }\n\n      // If only one APK has been found, select it even if it has not been\n      // specified explicitly on the comment line.\n      this.selectedFirefoxApk = packages[0];\n      log.info(`Selected Firefox for Android APK: ${this.selectedFirefoxApk}`);\n      return;\n    }\n\n    const filteredPackages = packages.filter((line) => line === firefoxApk);\n\n    if (filteredPackages.length === 0) {\n      const pkgsList = pkgsListMsg(filteredPackages);\n      throw new UsageError(\n        `Package ${firefoxApk} was not found in list: ${pkgsList}`\n      );\n    }\n\n    this.selectedFirefoxApk = filteredPackages[0];\n    log.debug(`Selected Firefox for Android APK: ${this.selectedFirefoxApk}`);\n  }\n\n  async adbForceStopSelectedPackage() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n    } = this;\n\n    log.info(`Stopping existing instances of ${selectedFirefoxApk}...`);\n    await adbUtils.amForceStopAPK(selectedAdbDevice, selectedFirefoxApk);\n  }\n\n  async adbCheckRuntimePermissions() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n    } = this;\n\n    log.debug(`Discovering Android version for ${selectedAdbDevice}...`);\n\n    const androidVersion = await adbUtils.getAndroidVersionNumber(\n      selectedAdbDevice\n    );\n\n    if (typeof androidVersion !== 'number' || Number.isNaN(androidVersion)) {\n      throw new WebExtError(`Invalid Android version: ${androidVersion}`);\n    }\n\n    log.debug(`Detected Android version ${androidVersion}`);\n\n    if (androidVersion < 23) {\n      return;\n    }\n\n    log.debug('Checking read/write permissions needed for web-ext' +\n              `on ${selectedFirefoxApk}...`);\n\n    // Runtime permission needed to be able to run Firefox on a temporarily created profile\n    // on android versions >= 23 (Android Marshmallow, which is the first version where\n    // these permissions are optional and have to be granted explicitly).\n    await adbUtils.ensureRequiredAPKRuntimePermissions(\n      selectedAdbDevice, selectedFirefoxApk, [\n        'android.permission.READ_EXTERNAL_STORAGE',\n        'android.permission.WRITE_EXTERNAL_STORAGE',\n      ]\n    );\n  }\n\n  async adbPrepareProfileDir() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n      params: {\n        customPrefs,\n        firefoxApp,\n      },\n    } = this;\n    // Create the preferences file and the Fennec temporary profile.\n    log.debug(`Preparing a temporary profile for ${selectedFirefoxApk}...`);\n\n    const profile = await firefoxApp.createProfile({\n      app: 'fennec',\n      customPrefs,\n    });\n\n    // Choose a artifacts dir name for the assets pushed to the\n    // Android device.\n    this.selectedArtifactsDir = await adbUtils.getOrCreateArtifactsDir(\n      selectedAdbDevice\n    );\n\n    const deviceProfileDir = this.getDeviceProfileDir();\n\n    await adbUtils.runShellCommand(selectedAdbDevice, [\n      'mkdir', '-p', deviceProfileDir,\n    ]);\n    await adbUtils.pushFile(selectedAdbDevice,\n                            path.join(profile.profileDir, 'user.js'),\n                            `${deviceProfileDir}/user.js`);\n\n    log.debug(`Created temporary profile at ${deviceProfileDir}.`);\n  }\n\n  async adbStartSelectedPackage() {\n    const {\n      adbUtils,\n      selectedFirefoxApk,\n      selectedAdbDevice,\n    } = this;\n\n    const deviceProfileDir = this.getDeviceProfileDir();\n\n    log.info(`Starting ${selectedFirefoxApk}...`);\n\n    log.debug(`Using profile ${deviceProfileDir}`);\n\n    await adbUtils.startFirefoxAPK(\n      selectedAdbDevice, selectedFirefoxApk, deviceProfileDir\n    );\n  }\n\n  async buildAndPushExtension(sourceDir: string) {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedArtifactsDir,\n      params: {\n        buildSourceDir,\n      },\n    } = this;\n\n    await withTempDir(async (tmpDir) => {\n      const {extensionPath} = await buildSourceDir(sourceDir, tmpDir.path());\n\n      const extFileName = path.basename(extensionPath, '.zip');\n\n      let adbExtensionPath = this.adbExtensionsPathBySourceDir.get(sourceDir);\n\n      if (!adbExtensionPath) {\n        adbExtensionPath = `${selectedArtifactsDir}/${extFileName}.xpi`;\n      }\n\n      log.debug(`Uploading ${extFileName} on the android device`);\n\n      await adbUtils.pushFile(\n        selectedAdbDevice, extensionPath, adbExtensionPath\n      );\n\n      log.debug(`Upload completed: ${adbExtensionPath}`);\n\n      this.adbExtensionsPathBySourceDir.set(sourceDir, adbExtensionPath);\n    });\n  }\n\n  async buildAndPushExtensions() {\n    for (const {sourceDir} of this.params.extensions) {\n      await this.buildAndPushExtension(sourceDir);\n    }\n  }\n\n  async adbDiscoveryAndForwardRDPUnixSocket() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n      params: {\n        firefoxAndroidTimeout,\n      },\n    } = this;\n\n    const stdin = this.params.stdin || process.stdin;\n\n    const {\n      unixSocketDiscoveryRetryInterval,\n    } = FirefoxAndroidExtensionRunner;\n\n    let {\n      unixSocketDiscoveryMaxTime,\n    } = FirefoxAndroidExtensionRunner;\n\n    if (typeof firefoxAndroidTimeout === 'number') {\n      unixSocketDiscoveryMaxTime = firefoxAndroidTimeout;\n    }\n\n    const handleCtrlC = (str, key) => {\n      if (key.ctrl && key.name === 'c') {\n        adbUtils.setUserAbortDiscovery(true);\n      }\n    };\n\n    // TODO: use noInput property to decide if we should\n    // disable direct keypress handling.\n    if (isTTY(stdin)) {\n      readline.emitKeypressEvents(stdin);\n      setRawMode(stdin, true);\n\n      stdin.on('keypress', handleCtrlC);\n    }\n\n    try {\n      // Got a debugger socket file to connect.\n      this.selectedRDPSocketFile = (\n        await adbUtils.discoverRDPUnixSocket(\n          selectedAdbDevice, selectedFirefoxApk, {\n            maxDiscoveryTime: unixSocketDiscoveryMaxTime,\n            retryInterval: unixSocketDiscoveryRetryInterval,\n          }\n        )\n      );\n    } finally {\n      if (isTTY(stdin)) {\n        stdin.removeListener('keypress', handleCtrlC);\n      }\n    }\n\n    log.debug(`RDP Socket File selected: ${this.selectedRDPSocketFile}`);\n\n    const tcpPort = await this.chooseLocalTcpPort();\n\n    // Log the choosen tcp port at info level (useful to the user to be able\n    // to connect the Firefox DevTools to the Firefox for Android instance).\n    log.info(`You can connect to this Android device on TCP port ${tcpPort}`);\n\n    const forwardSocketSpec = this.selectedRDPSocketFile.startsWith('@') ?\n      `localabstract:${this.selectedRDPSocketFile.substr(1)}`\n      : `localfilesystem:${this.selectedRDPSocketFile}`;\n\n    await adbUtils.setupForward(\n      selectedAdbDevice,\n      forwardSocketSpec,\n      `tcp:${tcpPort}`\n    );\n\n    this.selectedTCPPort = tcpPort;\n  }\n\n  chooseLocalTcpPort(): Promise<number> {\n    return new Promise((resolve) => {\n      const srv = net.createServer();\n      // $FLOW_FIXME: flow has his own opinions on this method signature.\n      srv.listen(0, () => {\n        const freeTcpPort = srv.address().port;\n        srv.close();\n        resolve(freeTcpPort);\n      });\n    });\n  }\n\n  async rdpInstallExtensions() {\n    const {\n      selectedTCPPort,\n      params: {\n        extensions,\n        firefoxClient,\n      },\n    } = this;\n\n    const remoteFirefox = this.remoteFirefox = await firefoxClient({\n      port: selectedTCPPort,\n    });\n\n    // Exit and cleanup the extension runner if the connection to the\n    // remote Firefox for Android instance has been closed.\n    remoteFirefox.client.on('end', () => {\n      if (!this.exiting) {\n        log.info('Exiting the device because Firefox for Android disconnected');\n        this.exit();\n      }\n    });\n\n    // Install all the temporary addons.\n    for (const extension of extensions) {\n      const {sourceDir} = extension;\n      const adbExtensionPath = this.adbExtensionsPathBySourceDir.get(\n        sourceDir\n      );\n\n      if (!adbExtensionPath) {\n        throw new WebExtError(\n          `ADB extension path for \"${sourceDir}\" was unexpectedly empty`\n        );\n      }\n\n      const addonId = await (\n        remoteFirefox.installTemporaryAddon(adbExtensionPath)\n          .then((installResult: FirefoxRDPResponseAddon) => {\n            return installResult.addon.id;\n          })\n      );\n\n      if (!addonId) {\n        throw new WebExtError(\n          'Received an empty addonId from ' +\n          `remoteFirefox.installTemporaryAddon(\"${adbExtensionPath}\")`\n        );\n      }\n\n      this.reloadableExtensions.set(extension.sourceDir, addonId);\n    }\n  }\n}\n","/* @flow */\nimport path from 'path';\n\nimport {fs} from 'mz';\nimport defaultAddonSigner from 'sign-addon';\n\nimport defaultBuilder from './build';\nimport getValidatedManifest, {getManifestId} from '../util/manifest';\nimport {withTempDir} from '../util/temp-dir';\nimport {isErrorWithCode, UsageError, WebExtError} from '../errors';\nimport {prepareArtifactsDir} from '../util/artifacts';\nimport {createLogger} from '../util/logger';\nimport type {ExtensionManifest} from '../util/manifest';\n\n\nconst log = createLogger(__filename);\n\nconst defaultAsyncFsReadFile = fs.readFile.bind(fs);\n\nexport const extensionIdFile = '.web-extension-id';\n\n// Sign command types and implementation.\n\nexport type SignParams = {|\n  apiKey: string,\n  apiProxy: string,\n  apiSecret: string,\n  apiUrlPrefix: string,\n  artifactsDir: string,\n  id?: string,\n  ignoreFiles?: Array<string>,\n  sourceDir: string,\n  timeout: number,\n  verbose?: boolean,\n  channel?: string,\n|};\n\nexport type SignOptions = {\n  build?: typeof defaultBuilder,\n  signAddon?: typeof defaultAddonSigner,\n  preValidatedManifest?: ExtensionManifest,\n  shouldExitProgram?: boolean,\n};\n\nexport type SignResult = {|\n  success: boolean,\n  id: string,\n  downloadedFiles: Array<string>,\n|};\n\nexport default function sign(\n  {\n    apiKey,\n    apiProxy,\n    apiSecret,\n    apiUrlPrefix,\n    artifactsDir,\n    id,\n    ignoreFiles = [],\n    sourceDir,\n    timeout,\n    verbose,\n    channel,\n  }: SignParams,\n  {\n    build = defaultBuilder,\n    preValidatedManifest,\n    signAddon = defaultAddonSigner,\n  }: SignOptions = {}\n): Promise<SignResult> {\n  return withTempDir(\n    async function(tmpDir) {\n      await prepareArtifactsDir(artifactsDir);\n\n      let manifestData;\n\n      if (preValidatedManifest) {\n        manifestData = preValidatedManifest;\n      } else {\n        manifestData = await getValidatedManifest(sourceDir);\n      }\n\n      const [buildResult, idFromSourceDir] = await Promise.all([\n        build({sourceDir, ignoreFiles, artifactsDir: tmpDir.path()},\n              {manifestData, showReadyMessage: false}),\n        getIdFromSourceDir(sourceDir),\n      ]);\n\n      const manifestId = getManifestId(manifestData);\n\n      if (id && manifestId) {\n        throw new UsageError(\n          `Cannot set custom ID ${id} because manifest.json ` +\n          `declares ID ${manifestId}`);\n      }\n      if (id) {\n        log.debug(`Using custom ID declared as --id=${id}`);\n      }\n\n      if (manifestId) {\n        id = manifestId;\n      }\n\n      if (!id && idFromSourceDir) {\n        log.info(\n          `Using previously auto-generated extension ID: ${idFromSourceDir}`);\n        id = idFromSourceDir;\n      }\n\n      if (!id) {\n        log.warn('No extension ID specified (it will be auto-generated)');\n      }\n\n      const signingResult = await signAddon({\n        apiKey,\n        apiSecret,\n        apiUrlPrefix,\n        apiProxy,\n        timeout,\n        verbose,\n        id,\n        xpiPath: buildResult.extensionPath,\n        version: manifestData.version,\n        downloadDir: artifactsDir,\n        channel,\n      });\n\n      if (signingResult.id) {\n        await saveIdToSourceDir(sourceDir, signingResult.id);\n      }\n\n      // All information about the downloaded files would have\n      // already been logged by signAddon().\n      if (signingResult.success) {\n        log.info(`Extension ID: ${signingResult.id}`);\n        log.info('SUCCESS');\n      } else {\n        log.info('FAIL');\n        throw new WebExtError(\n          'The extension could not be signed');\n      }\n\n      return signingResult;\n    }\n  );\n}\n\n\nexport async function getIdFromSourceDir(\n  sourceDir: string,\n  asyncFsReadFile: typeof defaultAsyncFsReadFile = defaultAsyncFsReadFile,\n): Promise<string | void> {\n  const filePath = path.join(sourceDir, extensionIdFile);\n\n  let content;\n\n  try {\n    content = await asyncFsReadFile(filePath);\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error)) {\n      log.debug(`No ID file found at: ${filePath}`);\n      return;\n    }\n    throw error;\n  }\n\n  let lines = content.toString().split('\\n');\n  lines = lines.filter((line) => {\n    line = line.trim();\n    if (line && !line.startsWith('#')) {\n      return line;\n    }\n  });\n\n  const id = lines[0];\n  log.debug(`Found extension ID ${id} in ${filePath}`);\n\n  if (!id) {\n    throw new UsageError(`No ID found in extension ID file ${filePath}`);\n  }\n\n  return id;\n}\n\n\nexport async function saveIdToSourceDir(\n  sourceDir: string, id: string\n): Promise<void> {\n  const filePath = path.join(sourceDir, extensionIdFile);\n  await fs.writeFile(filePath, [\n    '# This file was created by https://github.com/mozilla/web-ext',\n    '# Your auto-generated extension ID for addons.mozilla.org is:',\n    id.toString(),\n  ].join('\\n'));\n\n  log.debug(`Saved auto-generated ID ${id} to ${filePath}`);\n}\n","/* @flow */\nimport opn from 'opn';\n\nimport {createLogger} from '../util/logger';\n\nconst log = createLogger(__filename);\n\nexport type DocsParams = {\n  noInput?: boolean,\n  shouldExitProgram?: boolean,\n}\n\nexport type DocsOptions = {\n  openUrl?: typeof opn,\n}\n\nexport const url = 'https://developer.mozilla.org/en-US/Add-ons' +\n  '/WebExtensions/Getting_started_with_web-ext';\n\nexport default function docs(\n  params: DocsParams, {openUrl = opn}: DocsOptions = {}\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    openUrl(url, (error) => {\n      if (error) {\n        log.debug(`Encountered an error while opening URL ${url}`, error);\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n"],"sourceRoot":""}